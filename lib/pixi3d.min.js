var PIXI3D=function(v,p,be,ir,Te,H,ar,C,Xe,ge,St){"use strict";function sr(r){if(r&&r.__esModule)return r;var e=Object.create(null);return r&&Object.keys(r).forEach(function(t){if(t!=="default"){var n=Object.getOwnPropertyDescriptor(r,t);Object.defineProperty(e,t,n.get?n:{enumerable:!0,get:function(){return r[t]}})}}),e.default=r,Object.freeze(e)}var P=sr(p),O;(r=>{function e(t,n){return t[n]}r.get=e})(O||(O={}));var ue=(r=>(r[r.buffer=0]="buffer",r[r.json=1]="json",r[r.text=2]="text",r))(ue||{});class yt{setLoaderResourceExtensionType(e,t){let n=be.LoaderResource.XHR_RESPONSE_TYPE.TEXT;t===ue.buffer?n=be.LoaderResource.XHR_RESPONSE_TYPE.BUFFER:t===ue.json&&(n=be.LoaderResource.XHR_RESPONSE_TYPE.JSON),be.LoaderResource.setExtensionXhrType(e,n)}getInteractionPlugin(e){return e.plugins.interaction}get assets(){}isRendererDestroyed(e){return!e.gl}installRendererPlugin(e,t){p.Renderer.registerPlugin(e,t)}installLoaderPlugin(e,t){be.Loader.registerPlugin(t)}render(e,t,n){e.render(t,n)}}class Et extends yt{render(e,t,n){e.render(t,{renderTexture:n})}}class bt extends Et{installRendererPlugin(e,t){t.extension={type:O.get(P,"ExtensionType").RendererPlugin,name:e},O.get(P,"extensions").add(t)}installLoaderPlugin(e,t){t.extension={type:O.get(P,"ExtensionType").Loader,name:e},O.get(P,"extensions").add(t)}}class or extends bt{setLoaderResourceExtensionType(e,t){}getInteractionPlugin(e){}get assets(){return ir.Assets}isRendererDestroyed(e){return"_systemsHash"in e?Object.keys(e._systemsHash).length===0:!1}installRendererPlugin(e,t){t.extension={type:[O.get(P,"ExtensionType").RendererPlugin],name:e},O.get(P,"extensions").add(t)}installLoaderPlugin(e,t){t.extension={type:[O.get(P,"ExtensionType").Loader,O.get(P,"ExtensionType").LoadParser],name:e},O.get(P,"extensions").add(t)}}const lr="VERSION"in P&&O.get(P,"VERSION").startsWith("7"),hr="extensions"in P,ur="ArrayResource"in P,N=lr?new or:hr?new bt:ur?new Et:new yt;class j{constructor(e,t=[],n=[]){this.descriptor=e,this.buffers=t,this.images=n,this.textures=[]}static load(e,t,n){let i=new j(e);return dr(e,a=>{a.forEach(s=>i.buffers.push(s)),Mt(e,a,s=>{s.forEach(o=>i.images.push(o)),n&&n(i)},t)},t),i}static isValidBuffer(e){const t=new Uint32Array(e,0,3);return t[0]===1179937895&&t[1]===2}static isEmbeddedResource(e){return e&&e.startsWith("data:")}static fromBuffer(e,t){const n=[];let i=12;for(;i<e.byteLength;){const h=new Uint32Array(e,i,3);n.push({length:h[0],type:h[1],offset:i+8}),i+=h[0]+8}const a=new Uint8Array(e,n[0].offset,n[0].length),s=JSON.parse(new TextDecoder("utf-8").decode(a)),o=[];for(let h=1;h<n.length;h++)o.push(e.slice(n[h].offset,n[h].offset+n[h].length));Mt(s,o,h=>{t(new j(s,o,h))})}static async fromURL(e,t){if(!N.assets)throw new Error("PIXI3D: This feature is only available when using PixiJS v7+");const n=await Te.settings.ADAPTER.fetch(e,t);return new Promise(async i=>{if(e.includes(".glb")){let a=await n.arrayBuffer();j.fromBuffer(a,s=>{i(s)})}else{let a=await n.json();j.load(a,new cr(e),s=>{i(s)})}})}}class cr{constructor(e){this.parentURL=e}load(e,t){const n=this.parentURL.substring(0,this.parentURL.lastIndexOf("/")+1)+e;(async()=>{if(!N.assets)throw new Error("PIXI3D: Assets are not available in current version of PixiJS.");let i={};if(n.includes(".bin")){const a=await Te.settings.ADAPTER.fetch(n);i.data=await a.arrayBuffer()}else{let a=await N.assets.load(n);a&&(i.texture=a)}t(i)})()}}function Mt(r,e,t,n){const i=[];if(!r.images||r.images.length===0)return t(i);let a=r.images.filter(c=>typeof c.bufferView!="number"&&j.isEmbeddedResource(c.uri)).map((c,f)=>f),s=r.images.filter(c=>typeof c.bufferView!="number"&&!j.isEmbeddedResource(c.uri)).map((c,f)=>f),o=r.images.filter(c=>typeof c.bufferView=="number").map((c,f)=>f);for(let c=0;c<a.length;c++){let f=a[c],_=r.images[f];i[f]=p.Texture.from(_.uri)}if(o.length===0&&s.length===0)return t(i);if(s.length>0&&!n)throw new Error("PIXI3D: A resource loader is required when image is external.");const h=(c,f,_)=>{n==null||n.load(c.uri,m=>{m.texture&&(i[f]=m.texture,_())})},l=(c,f,_)=>{fr(c,r,e,m=>{i[f]=m,_()})};let u=s.length,d=o.length;for(let c=0;c<s.length;c++){let f=s[c],_=r.images[f];h(_,f,()=>{--u===0&&d===0&&t(i)})}for(let c=0;c<o.length;c++){let f=o[c],_=r.images[f];l(_,f,()=>{--d===0&&u===0&&t(i)})}}function dr(r,e,t){const n=[],i=r.buffers.filter(h=>j.isEmbeddedResource(h.uri)).map((h,l)=>l);for(let h=0;h<i.length;h++){let l=i[h],u=r.buffers[l];n[l]=mr(u.uri)}const a=r.buffers.filter(h=>!j.isEmbeddedResource(h.uri)).map((h,l)=>l);if(a.length===0)return e(n);if(!t)throw new Error("PIXI3D: A resource loader is required when buffer is not embedded.");const s=(h,l,u)=>{t.load(h,d=>{n[l]=d.data,u()})};let o=a.length;for(let h=0;h<a.length;h++){let l=a[h],u=r.buffers[l];s(u.uri,l,()=>{--o===0&&e(n)})}}function fr(r,e,t,n){const i=e.bufferViews[r.bufferView],a=new Uint8Array(t[i.buffer],i.byteOffset,i.byteLength),s=new Blob([a],{type:r.mimeType}),o=new FileReader;o.onload=()=>{n(p.Texture.from(o.result))},o.readAsDataURL(s)}function mr(r){return Uint8Array.from(atob(r.split(",")[1]),e=>e.charCodeAt(0)).buffer}const Rt={use:function(r,e){if(r.extension!=="gltf")return e();let t=this;j.load(r.data,new _r(t,r),n=>{Object.assign(r,{gltf:n}),e()})},add:function(){N.setLoaderResourceExtensionType("bin",ue.buffer),N.setLoaderResourceExtensionType("gltf",ue.json)},test(r){return r.includes(".gltf")||r.includes(".glb")},async load(r){return await j.fromURL(r)}};N.installLoaderPlugin("gltf",Rt);class _r{constructor(e,t){this._loader=e,this._resource=t}load(e,t){const n=this._resource.url.substring(0,this._resource.url.lastIndexOf("/")+1)+e;if(!this._loader.resources[n])this._loader.add({parentResource:this._resource,url:n,onComplete:t});else if(this._loader.resources[n].data)t(this._loader.resources[n]);else{let i=this._loader.onProgress.add((a,s)=>{s.url===n&&(t(s),i.detach())})}}}const Ct={use:function(r,e){if(r.extension!=="glb")return e();if(j.isValidBuffer(r.data))j.fromBuffer(r.data,t=>{Object.assign(r,{gltf:t}),e()});else return e()},add:function(){N.setLoaderResourceExtensionType("glb",ue.buffer)}};N.installLoaderPlugin("cubemap",Ct);var xe=1e-6,W=typeof Float32Array!="undefined"?Float32Array:Array;Math.hypot||(Math.hypot=function(){for(var r=0,e=arguments.length;e--;)r+=arguments[e]*arguments[e];return Math.sqrt(r)});function gr(){var r=new W(9);return W!=Float32Array&&(r[1]=0,r[2]=0,r[3]=0,r[5]=0,r[6]=0,r[7]=0),r[0]=1,r[4]=1,r[8]=1,r}function pr(r,e,t){var n=e[0],i=e[1],a=e[2],s=e[3],o=e[4],h=e[5],l=e[6],u=e[7],d=e[8],c=t[0],f=t[1],_=t[2],m=t[3],g=t[4],A=t[5],M=t[6],w=t[7],S=t[8];return r[0]=c*n+f*s+_*l,r[1]=c*i+f*o+_*u,r[2]=c*a+f*h+_*d,r[3]=m*n+g*s+A*l,r[4]=m*i+g*o+A*u,r[5]=m*a+g*h+A*d,r[6]=M*n+w*s+S*l,r[7]=M*i+w*o+S*u,r[8]=M*a+w*h+S*d,r}function vr(){var r=new W(16);return W!=Float32Array&&(r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[11]=0,r[12]=0,r[13]=0,r[14]=0),r[0]=1,r[5]=1,r[10]=1,r[15]=1,r}function Ar(r,e){return r[0]=e[0],r[1]=e[1],r[2]=e[2],r[3]=e[3],r[4]=e[4],r[5]=e[5],r[6]=e[6],r[7]=e[7],r[8]=e[8],r[9]=e[9],r[10]=e[10],r[11]=e[11],r[12]=e[12],r[13]=e[13],r[14]=e[14],r[15]=e[15],r}function It(r){return r[0]=1,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=1,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[10]=1,r[11]=0,r[12]=0,r[13]=0,r[14]=0,r[15]=1,r}function Tr(r,e){if(r===e){var t=e[1],n=e[2],i=e[3],a=e[6],s=e[7],o=e[11];r[1]=e[4],r[2]=e[8],r[3]=e[12],r[4]=t,r[6]=e[9],r[7]=e[13],r[8]=n,r[9]=a,r[11]=e[14],r[12]=i,r[13]=s,r[14]=o}else r[0]=e[0],r[1]=e[4],r[2]=e[8],r[3]=e[12],r[4]=e[1],r[5]=e[5],r[6]=e[9],r[7]=e[13],r[8]=e[2],r[9]=e[6],r[10]=e[10],r[11]=e[14],r[12]=e[3],r[13]=e[7],r[14]=e[11],r[15]=e[15];return r}function xr(r,e){var t=e[0],n=e[1],i=e[2],a=e[3],s=e[4],o=e[5],h=e[6],l=e[7],u=e[8],d=e[9],c=e[10],f=e[11],_=e[12],m=e[13],g=e[14],A=e[15],M=t*o-n*s,w=t*h-i*s,S=t*l-a*s,y=n*h-i*o,E=n*l-a*o,B=i*l-a*h,z=u*m-d*_,Y=u*g-c*_,Q=u*A-f*_,G=d*g-c*m,F=d*A-f*m,L=c*A-f*g,R=M*L-w*F+S*G+y*Q-E*Y+B*z;return R?(R=1/R,r[0]=(o*L-h*F+l*G)*R,r[1]=(i*F-n*L-a*G)*R,r[2]=(m*B-g*E+A*y)*R,r[3]=(c*E-d*B-f*y)*R,r[4]=(h*Q-s*L-l*Y)*R,r[5]=(t*L-i*Q+a*Y)*R,r[6]=(g*S-_*B-A*w)*R,r[7]=(u*B-c*S+f*w)*R,r[8]=(s*F-o*Q+l*z)*R,r[9]=(n*Q-t*F-a*z)*R,r[10]=(_*E-m*S+A*M)*R,r[11]=(d*S-u*E-f*M)*R,r[12]=(o*Y-s*G-h*z)*R,r[13]=(t*G-n*Y+i*z)*R,r[14]=(m*w-_*y-g*M)*R,r[15]=(u*y-d*w+c*M)*R,r):null}function wr(r,e,t){var n=e[0],i=e[1],a=e[2],s=e[3],o=e[4],h=e[5],l=e[6],u=e[7],d=e[8],c=e[9],f=e[10],_=e[11],m=e[12],g=e[13],A=e[14],M=e[15],w=t[0],S=t[1],y=t[2],E=t[3];return r[0]=w*n+S*o+y*d+E*m,r[1]=w*i+S*h+y*c+E*g,r[2]=w*a+S*l+y*f+E*A,r[3]=w*s+S*u+y*_+E*M,w=t[4],S=t[5],y=t[6],E=t[7],r[4]=w*n+S*o+y*d+E*m,r[5]=w*i+S*h+y*c+E*g,r[6]=w*a+S*l+y*f+E*A,r[7]=w*s+S*u+y*_+E*M,w=t[8],S=t[9],y=t[10],E=t[11],r[8]=w*n+S*o+y*d+E*m,r[9]=w*i+S*h+y*c+E*g,r[10]=w*a+S*l+y*f+E*A,r[11]=w*s+S*u+y*_+E*M,w=t[12],S=t[13],y=t[14],E=t[15],r[12]=w*n+S*o+y*d+E*m,r[13]=w*i+S*h+y*c+E*g,r[14]=w*a+S*l+y*f+E*A,r[15]=w*s+S*u+y*_+E*M,r}function Sr(r,e,t){var n=t[0],i=t[1],a=t[2],s,o,h,l,u,d,c,f,_,m,g,A;return e===r?(r[12]=e[0]*n+e[4]*i+e[8]*a+e[12],r[13]=e[1]*n+e[5]*i+e[9]*a+e[13],r[14]=e[2]*n+e[6]*i+e[10]*a+e[14],r[15]=e[3]*n+e[7]*i+e[11]*a+e[15]):(s=e[0],o=e[1],h=e[2],l=e[3],u=e[4],d=e[5],c=e[6],f=e[7],_=e[8],m=e[9],g=e[10],A=e[11],r[0]=s,r[1]=o,r[2]=h,r[3]=l,r[4]=u,r[5]=d,r[6]=c,r[7]=f,r[8]=_,r[9]=m,r[10]=g,r[11]=A,r[12]=s*n+u*i+_*a+e[12],r[13]=o*n+d*i+m*a+e[13],r[14]=h*n+c*i+g*a+e[14],r[15]=l*n+f*i+A*a+e[15]),r}function yr(r,e,t){var n=t[0],i=t[1],a=t[2];return r[0]=e[0]*n,r[1]=e[1]*n,r[2]=e[2]*n,r[3]=e[3]*n,r[4]=e[4]*i,r[5]=e[5]*i,r[6]=e[6]*i,r[7]=e[7]*i,r[8]=e[8]*a,r[9]=e[9]*a,r[10]=e[10]*a,r[11]=e[11]*a,r[12]=e[12],r[13]=e[13],r[14]=e[14],r[15]=e[15],r}function Er(r,e,t,n){var i=n[0],a=n[1],s=n[2],o=Math.hypot(i,a,s),h,l,u,d,c,f,_,m,g,A,M,w,S,y,E,B,z,Y,Q,G,F,L,R,Z;return o<xe?null:(o=1/o,i*=o,a*=o,s*=o,h=Math.sin(t),l=Math.cos(t),u=1-l,d=e[0],c=e[1],f=e[2],_=e[3],m=e[4],g=e[5],A=e[6],M=e[7],w=e[8],S=e[9],y=e[10],E=e[11],B=i*i*u+l,z=a*i*u+s*h,Y=s*i*u-a*h,Q=i*a*u-s*h,G=a*a*u+l,F=s*a*u+i*h,L=i*s*u+a*h,R=a*s*u-i*h,Z=s*s*u+l,r[0]=d*B+m*z+w*Y,r[1]=c*B+g*z+S*Y,r[2]=f*B+A*z+y*Y,r[3]=_*B+M*z+E*Y,r[4]=d*Q+m*G+w*F,r[5]=c*Q+g*G+S*F,r[6]=f*Q+A*G+y*F,r[7]=_*Q+M*G+E*F,r[8]=d*L+m*R+w*Z,r[9]=c*L+g*R+S*Z,r[10]=f*L+A*R+y*Z,r[11]=_*L+M*R+E*Z,e!==r&&(r[12]=e[12],r[13]=e[13],r[14]=e[14],r[15]=e[15]),r)}function br(r,e,t){var n=Math.sin(t),i=Math.cos(t),a=e[4],s=e[5],o=e[6],h=e[7],l=e[8],u=e[9],d=e[10],c=e[11];return e!==r&&(r[0]=e[0],r[1]=e[1],r[2]=e[2],r[3]=e[3],r[12]=e[12],r[13]=e[13],r[14]=e[14],r[15]=e[15]),r[4]=a*i+l*n,r[5]=s*i+u*n,r[6]=o*i+d*n,r[7]=h*i+c*n,r[8]=l*i-a*n,r[9]=u*i-s*n,r[10]=d*i-o*n,r[11]=c*i-h*n,r}function Mr(r,e,t){var n=Math.sin(t),i=Math.cos(t),a=e[0],s=e[1],o=e[2],h=e[3],l=e[8],u=e[9],d=e[10],c=e[11];return e!==r&&(r[4]=e[4],r[5]=e[5],r[6]=e[6],r[7]=e[7],r[12]=e[12],r[13]=e[13],r[14]=e[14],r[15]=e[15]),r[0]=a*i-l*n,r[1]=s*i-u*n,r[2]=o*i-d*n,r[3]=h*i-c*n,r[8]=a*n+l*i,r[9]=s*n+u*i,r[10]=o*n+d*i,r[11]=h*n+c*i,r}function Rr(r,e,t){var n=Math.sin(t),i=Math.cos(t),a=e[0],s=e[1],o=e[2],h=e[3],l=e[4],u=e[5],d=e[6],c=e[7];return e!==r&&(r[8]=e[8],r[9]=e[9],r[10]=e[10],r[11]=e[11],r[12]=e[12],r[13]=e[13],r[14]=e[14],r[15]=e[15]),r[0]=a*i+l*n,r[1]=s*i+u*n,r[2]=o*i+d*n,r[3]=h*i+c*n,r[4]=l*i-a*n,r[5]=u*i-s*n,r[6]=d*i-o*n,r[7]=c*i-h*n,r}function Cr(r,e){return r[0]=1,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=1,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[10]=1,r[11]=0,r[12]=e[0],r[13]=e[1],r[14]=e[2],r[15]=1,r}function Ir(r,e){return r[0]=e[0],r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=e[1],r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[10]=e[2],r[11]=0,r[12]=0,r[13]=0,r[14]=0,r[15]=1,r}function Nr(r,e,t){var n=t[0],i=t[1],a=t[2],s=Math.hypot(n,i,a),o,h,l;return s<xe?null:(s=1/s,n*=s,i*=s,a*=s,o=Math.sin(e),h=Math.cos(e),l=1-h,r[0]=n*n*l+h,r[1]=i*n*l+a*o,r[2]=a*n*l-i*o,r[3]=0,r[4]=n*i*l-a*o,r[5]=i*i*l+h,r[6]=a*i*l+n*o,r[7]=0,r[8]=n*a*l+i*o,r[9]=i*a*l-n*o,r[10]=a*a*l+h,r[11]=0,r[12]=0,r[13]=0,r[14]=0,r[15]=1,r)}function Fr(r,e){return r[0]=e[12],r[1]=e[13],r[2]=e[14],r}function Nt(r,e){var t=e[0],n=e[1],i=e[2],a=e[4],s=e[5],o=e[6],h=e[8],l=e[9],u=e[10];return r[0]=Math.hypot(t,n,i),r[1]=Math.hypot(a,s,o),r[2]=Math.hypot(h,l,u),r}function Lr(r,e){var t=new W(3);Nt(t,e);var n=1/t[0],i=1/t[1],a=1/t[2],s=e[0]*n,o=e[1]*i,h=e[2]*a,l=e[4]*n,u=e[5]*i,d=e[6]*a,c=e[8]*n,f=e[9]*i,_=e[10]*a,m=s+u+_,g=0;return m>0?(g=Math.sqrt(m+1)*2,r[3]=.25*g,r[0]=(d-f)/g,r[1]=(c-h)/g,r[2]=(o-l)/g):s>u&&s>_?(g=Math.sqrt(1+s-u-_)*2,r[3]=(d-f)/g,r[0]=.25*g,r[1]=(o+l)/g,r[2]=(c+h)/g):u>_?(g=Math.sqrt(1+u-s-_)*2,r[3]=(c-h)/g,r[0]=(o+l)/g,r[1]=.25*g,r[2]=(d+f)/g):(g=Math.sqrt(1+_-s-u)*2,r[3]=(o-l)/g,r[0]=(c+h)/g,r[1]=(d+f)/g,r[2]=.25*g),r}function Pr(r,e,t,n){var i=e[0],a=e[1],s=e[2],o=e[3],h=i+i,l=a+a,u=s+s,d=i*h,c=i*l,f=i*u,_=a*l,m=a*u,g=s*u,A=o*h,M=o*l,w=o*u,S=n[0],y=n[1],E=n[2];return r[0]=(1-(_+g))*S,r[1]=(c+w)*S,r[2]=(f-M)*S,r[3]=0,r[4]=(c-w)*y,r[5]=(1-(d+g))*y,r[6]=(m+A)*y,r[7]=0,r[8]=(f+M)*E,r[9]=(m-A)*E,r[10]=(1-(d+_))*E,r[11]=0,r[12]=t[0],r[13]=t[1],r[14]=t[2],r[15]=1,r}function Or(r,e){var t=e[0],n=e[1],i=e[2],a=e[3],s=t+t,o=n+n,h=i+i,l=t*s,u=n*s,d=n*o,c=i*s,f=i*o,_=i*h,m=a*s,g=a*o,A=a*h;return r[0]=1-d-_,r[1]=u+A,r[2]=c-g,r[3]=0,r[4]=u-A,r[5]=1-l-_,r[6]=f+m,r[7]=0,r[8]=c+g,r[9]=f-m,r[10]=1-l-d,r[11]=0,r[12]=0,r[13]=0,r[14]=0,r[15]=1,r}function Ur(r,e,t,n,i){var a=1/Math.tan(e/2),s;return r[0]=a/t,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=a,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[11]=-1,r[12]=0,r[13]=0,r[15]=0,i!=null&&i!==1/0?(s=1/(n-i),r[10]=(i+n)*s,r[14]=2*i*n*s):(r[10]=-1,r[14]=-2*n),r}var Dr=Ur;function Br(r,e,t,n,i,a,s){var o=1/(e-t),h=1/(n-i),l=1/(a-s);return r[0]=-2*o,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=-2*h,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[10]=2*l,r[11]=0,r[12]=(e+t)*o,r[13]=(i+n)*h,r[14]=(s+a)*l,r[15]=1,r}var Gr=Br;function Vr(r,e,t,n){var i,a,s,o,h,l,u,d,c,f,_=e[0],m=e[1],g=e[2],A=n[0],M=n[1],w=n[2],S=t[0],y=t[1],E=t[2];return Math.abs(_-S)<xe&&Math.abs(m-y)<xe&&Math.abs(g-E)<xe?It(r):(u=_-S,d=m-y,c=g-E,f=1/Math.hypot(u,d,c),u*=f,d*=f,c*=f,i=M*c-w*d,a=w*u-A*c,s=A*d-M*u,f=Math.hypot(i,a,s),f?(f=1/f,i*=f,a*=f,s*=f):(i=0,a=0,s=0),o=d*s-c*a,h=c*i-u*s,l=u*a-d*i,f=Math.hypot(o,h,l),f?(f=1/f,o*=f,h*=f,l*=f):(o=0,h=0,l=0),r[0]=i,r[1]=o,r[2]=u,r[3]=0,r[4]=a,r[5]=h,r[6]=d,r[7]=0,r[8]=s,r[9]=l,r[10]=c,r[11]=0,r[12]=-(i*_+a*m+s*g),r[13]=-(o*_+h*m+l*g),r[14]=-(u*_+d*m+c*g),r[15]=1,r)}function Hr(r,e,t,n){var i=e[0],a=e[1],s=e[2],o=n[0],h=n[1],l=n[2],u=i-t[0],d=a-t[1],c=s-t[2],f=u*u+d*d+c*c;f>0&&(f=1/Math.sqrt(f),u*=f,d*=f,c*=f);var _=h*c-l*d,m=l*u-o*c,g=o*d-h*u;return f=_*_+m*m+g*g,f>0&&(f=1/Math.sqrt(f),_*=f,m*=f,g*=f),r[0]=_,r[1]=m,r[2]=g,r[3]=0,r[4]=d*g-c*m,r[5]=c*_-u*g,r[6]=u*m-d*_,r[7]=0,r[8]=u,r[9]=d,r[10]=c,r[11]=0,r[12]=i,r[13]=a,r[14]=s,r[15]=1,r}function Je(){var r=new W(3);return W!=Float32Array&&(r[0]=0,r[1]=0,r[2]=0),r}function Ft(r){var e=r[0],t=r[1],n=r[2];return Math.hypot(e,t,n)}function Ke(r,e,t){var n=new W(3);return n[0]=r,n[1]=e,n[2]=t,n}function zr(r,e){return r[0]=e[0],r[1]=e[1],r[2]=e[2],r}function jr(r,e,t,n){return r[0]=e,r[1]=t,r[2]=n,r}function kr(r,e,t){return r[0]=e[0]+t[0],r[1]=e[1]+t[1],r[2]=e[2]+t[2],r}function Qr(r,e,t){return r[0]=e[0]-t[0],r[1]=e[1]-t[1],r[2]=e[2]-t[2],r}function Wr(r,e,t){return r[0]=e[0]*t[0],r[1]=e[1]*t[1],r[2]=e[2]*t[2],r}function Xr(r,e,t){return r[0]=e[0]*t,r[1]=e[1]*t,r[2]=e[2]*t,r}function Jr(r,e){var t=e[0]-r[0],n=e[1]-r[1],i=e[2]-r[2];return Math.hypot(t,n,i)}function Kr(r,e){var t=e[0]-r[0],n=e[1]-r[1],i=e[2]-r[2];return t*t+n*n+i*i}function qr(r){var e=r[0],t=r[1],n=r[2];return e*e+t*t+n*n}function Yr(r,e){return r[0]=-e[0],r[1]=-e[1],r[2]=-e[2],r}function Zr(r,e){return r[0]=1/e[0],r[1]=1/e[1],r[2]=1/e[2],r}function Lt(r,e){var t=e[0],n=e[1],i=e[2],a=t*t+n*n+i*i;return a>0&&(a=1/Math.sqrt(a)),r[0]=e[0]*a,r[1]=e[1]*a,r[2]=e[2]*a,r}function Pt(r,e){return r[0]*e[0]+r[1]*e[1]+r[2]*e[2]}function Le(r,e,t){var n=e[0],i=e[1],a=e[2],s=t[0],o=t[1],h=t[2];return r[0]=i*h-a*o,r[1]=a*s-n*h,r[2]=n*o-i*s,r}function $r(r,e,t,n){var i=e[0],a=e[1],s=e[2];return r[0]=i+n*(t[0]-i),r[1]=a+n*(t[1]-a),r[2]=s+n*(t[2]-s),r}function en(r,e,t){var n=e[0],i=e[1],a=e[2],s=t[3]*n+t[7]*i+t[11]*a+t[15];return s=s||1,r[0]=(t[0]*n+t[4]*i+t[8]*a+t[12])/s,r[1]=(t[1]*n+t[5]*i+t[9]*a+t[13])/s,r[2]=(t[2]*n+t[6]*i+t[10]*a+t[14])/s,r}function tn(r,e,t){var n=t[0],i=t[1],a=t[2],s=t[3],o=e[0],h=e[1],l=e[2],u=i*l-a*h,d=a*o-n*l,c=n*h-i*o,f=i*c-a*d,_=a*u-n*c,m=n*d-i*u,g=s*2;return u*=g,d*=g,c*=g,f*=2,_*=2,m*=2,r[0]=o+u+f,r[1]=h+d+_,r[2]=l+c+m,r}var rn=Ft;(function(){var r=Je();return function(e,t,n,i,a,s){var o,h;for(t||(t=3),n||(n=0),i?h=Math.min(i*t+n,e.length):h=e.length,o=n;o<h;o+=t)r[0]=e[o],r[1]=e[o+1],r[2]=e[o+2],a(r,r,s),e[o]=r[0],e[o+1]=r[1],e[o+2]=r[2];return e}})();function nn(){var r=new W(4);return W!=Float32Array&&(r[0]=0,r[1]=0,r[2]=0,r[3]=0),r}function Ot(r,e,t,n){var i=new W(4);return i[0]=r,i[1]=e,i[2]=t,i[3]=n,i}function Ut(r,e,t,n,i){return r[0]=e,r[1]=t,r[2]=n,r[3]=i,r}function an(r,e){var t=e[0],n=e[1],i=e[2],a=e[3],s=t*t+n*n+i*i+a*a;return s>0&&(s=1/Math.sqrt(s)),r[0]=t*s,r[1]=n*s,r[2]=i*s,r[3]=a*s,r}function sn(r,e,t){var n=e[0],i=e[1],a=e[2],s=e[3];return r[0]=t[0]*n+t[4]*i+t[8]*a+t[12]*s,r[1]=t[1]*n+t[5]*i+t[9]*a+t[13]*s,r[2]=t[2]*n+t[6]*i+t[10]*a+t[14]*s,r[3]=t[3]*n+t[7]*i+t[11]*a+t[15]*s,r}(function(){var r=nn();return function(e,t,n,i,a,s){var o,h;for(t||(t=4),n||(n=0),i?h=Math.min(i*t+n,e.length):h=e.length,o=n;o<h;o+=t)r[0]=e[o],r[1]=e[o+1],r[2]=e[o+2],r[3]=e[o+3],a(r,r,s),e[o]=r[0],e[o+1]=r[1],e[o+2]=r[2],e[o+3]=r[3];return e}})();function qe(){var r=new W(4);return W!=Float32Array&&(r[0]=0,r[1]=0,r[2]=0),r[3]=1,r}function on(r,e,t){t=t*.5;var n=Math.sin(t);return r[0]=n*e[0],r[1]=n*e[1],r[2]=n*e[2],r[3]=Math.cos(t),r}function ln(r,e,t){t*=.5;var n=e[0],i=e[1],a=e[2],s=e[3],o=Math.sin(t),h=Math.cos(t);return r[0]=n*h+s*o,r[1]=i*h+a*o,r[2]=a*h-i*o,r[3]=s*h-n*o,r}function hn(r,e,t){t*=.5;var n=e[0],i=e[1],a=e[2],s=e[3],o=Math.sin(t),h=Math.cos(t);return r[0]=n*h-a*o,r[1]=i*h+s*o,r[2]=a*h+n*o,r[3]=s*h-i*o,r}function un(r,e,t){t*=.5;var n=e[0],i=e[1],a=e[2],s=e[3],o=Math.sin(t),h=Math.cos(t);return r[0]=n*h+i*o,r[1]=i*h-n*o,r[2]=a*h+s*o,r[3]=s*h-a*o,r}function Pe(r,e,t,n){var i=e[0],a=e[1],s=e[2],o=e[3],h=t[0],l=t[1],u=t[2],d=t[3],c,f,_,m,g;return f=i*h+a*l+s*u+o*d,f<0&&(f=-f,h=-h,l=-l,u=-u,d=-d),1-f>xe?(c=Math.acos(f),_=Math.sin(c),m=Math.sin((1-n)*c)/_,g=Math.sin(n*c)/_):(m=1-n,g=n),r[0]=m*i+g*h,r[1]=m*a+g*l,r[2]=m*s+g*u,r[3]=m*o+g*d,r}function cn(r,e){return r[0]=-e[0],r[1]=-e[1],r[2]=-e[2],r[3]=e[3],r}function dn(r,e){var t=e[0]+e[4]+e[8],n;if(t>0)n=Math.sqrt(t+1),r[3]=.5*n,n=.5/n,r[0]=(e[5]-e[7])*n,r[1]=(e[6]-e[2])*n,r[2]=(e[1]-e[3])*n;else{var i=0;e[4]>e[0]&&(i=1),e[8]>e[i*3+i]&&(i=2);var a=(i+1)%3,s=(i+2)%3;n=Math.sqrt(e[i*3+i]-e[a*3+a]-e[s*3+s]+1),r[i]=.5*n,n=.5/n,r[3]=(e[a*3+s]-e[s*3+a])*n,r[a]=(e[a*3+i]+e[i*3+a])*n,r[s]=(e[s*3+i]+e[i*3+s])*n}return r}function fn(r,e,t,n){var i=.5*Math.PI/180;e*=i,t*=i,n*=i;var a=Math.sin(e),s=Math.cos(e),o=Math.sin(t),h=Math.cos(t),l=Math.sin(n),u=Math.cos(n);return r[0]=a*h*u-s*o*l,r[1]=s*o*u+a*h*l,r[2]=s*h*l-a*o*u,r[3]=s*h*u+a*o*l,r}var mn=Ot,_n=Ut,Ye=an,gn=function(){var r=Je(),e=Ke(1,0,0),t=Ke(0,1,0);return function(n,i,a){var s=Pt(i,a);return s<-.999999?(Le(r,e,i),rn(r)<1e-6&&Le(r,t,i),Lt(r,r),on(n,r,Math.PI),n):s>.999999?(n[0]=0,n[1]=0,n[2]=0,n[3]=1,n):(Le(r,i,a),n[0]=r[0],n[1]=r[1],n[2]=r[2],n[3]=1+s,Ye(n,n))}}();(function(){var r=qe(),e=qe();return function(t,n,i,a,s,o){return Pe(r,n,s,o),Pe(e,i,a,o),Pe(t,r,e,2*o*(1-o)),t}})(),function(){var r=gr();return function(e,t,n,i){return r[0]=n[0],r[3]=n[1],r[6]=n[2],r[1]=i[0],r[4]=i[1],r[7]=i[2],r[2]=-t[0],r[5]=-t[1],r[8]=-t[2],Ye(e,dn(e,r))}}();class x{static set(e,t,n,i=new Float32Array(3)){return jr(i,e,t,n)}static fromValues(e,t,n){return Ke(e,t,n)}static create(){return Je()}static add(e,t,n=new Float32Array(3)){return kr(n,e,t)}static transformQuat(e,t,n=new Float32Array(3)){return tn(n,e,t)}static subtract(e,t,n=new Float32Array(3)){return Qr(n,e,t)}static scale(e,t,n=new Float32Array(3)){return Xr(n,e,t)}static dot(e,t){return Pt(e,t)}static normalize(e,t=new Float32Array(3)){return Lt(t,e)}static cross(e,t,n=new Float32Array(3)){return Le(n,e,t)}static transformMat4(e,t,n=new Float32Array(3)){return en(n,e,t)}static copy(e,t=new Float32Array(3)){return zr(t,e)}static magnitude(e){return Ft(e)}static squaredMagnitude(e){return qr(e)}static inverse(e,t=new Float32Array(3)){return Zr(t,e)}static negate(e,t=new Float32Array(3)){return Yr(t,e)}static multiply(e,t,n=new Float32Array(3)){return Wr(n,e,t)}static distance(e,t){return Jr(e,t)}static squaredDistance(e,t){return Kr(e,t)}static lerp(e,t,n,i=new Float32Array(3)){return $r(i,e,t,n)}}class D{static set(e,t,n,i,a=new Float32Array(4)){return _n(a,e,t,n,i)}static fromValues(e,t,n,i){return mn(e,t,n,i)}static create(){return qe()}static normalize(e,t=new Float32Array(4)){return Ye(t,e)}static slerp(e,t,n,i=new Float32Array(4)){return Pe(i,e,t,n)}static fromEuler(e,t,n,i=new Float32Array(4)){return fn(i,e,t,n)}static conjugate(e,t=new Float32Array(4)){return cn(t,e)}static rotateX(e,t,n=new Float32Array(4)){return ln(n,e,t)}static rotateY(e,t,n=new Float32Array(4)){return hn(n,e,t)}static rotateZ(e,t,n=new Float32Array(4)){return un(n,e,t)}static rotationTo(e,t,n=new Float32Array(4)){return gn(n,e,t)}}const pe=new Float32Array(4);class X extends H.ObservablePoint{constructor(e=0,t=0,n=0,i=1,a=()=>{},s=void 0){super(a,s),this._array=new Float32Array(4),this._array.set([e,t,n,i])}get array(){return this._array}set array(e){this.setFrom(e)}get x(){return this._array[0]}set x(e){this._array[0]!==e&&(this._array[0]=e,this.cb.call(this.scope))}get y(){return this._array[1]}set y(e){this._array[1]!==e&&(this._array[1]=e,this.cb.call(this.scope))}get z(){return this._array[2]}set z(e){this._array[2]!==e&&(this._array[2]=e,this.cb.call(this.scope))}get w(){return this._array[3]}set w(e){this._array[3]!==e&&(this._array[3]=e,this.cb.call(this.scope))}setEulerAngles(e,t,n){D.fromEuler(e,t,n,this._array),this.cb.call(this.scope)}clone(e=this.cb,t=this.scope){return new X(this.x,this.y,this.z,this.w,e,t)}copyFrom(e){return(this._array[0]!==e.x||this._array[1]!==e.y||this._array[2]!==e.z||this._array[3]!==e.w)&&(this._array[0]=e.x,this._array[1]=e.y,this._array[2]=e.z,this._array[3]=e.w,this.cb.call(this.scope)),this}copyTo(e){return e instanceof X&&e.set(this.x,this.y,this.z,this.w),e}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}set(e,t=e,n=e,i=e){return(this._array[0]!==e||this._array[1]!==t||this._array[2]!==n||this._array[3]!==i)&&(this._array[0]=e,this._array[1]=t,this._array[2]=n,this._array[3]=i,this.cb.call(this.scope)),this}setFrom(e){return this.set(e[0],e[1],e[2],e[3]),this}normalize(e=new X){return e.setFrom(D.normalize(this._array,pe))}static slerp(e,t,n,i=new X){return i.setFrom(D.slerp(e.array,t.array,n,pe))}static fromEuler(e,t,n,i=new X){return i.setFrom(D.fromEuler(e,t,n,pe))}static conjugate(e,t=new X){return t.setFrom(D.conjugate(e.array,pe))}static rotateX(e,t,n=new X){return n.setFrom(D.rotateX(e.array,t,pe))}static rotateY(e,t,n=new X){return n.setFrom(D.rotateY(e.array,t,pe))}static rotateZ(e,t,n=new X){return n.setFrom(D.rotateZ(e.array,t,pe))}}class T{static getTranslation(e,t=new Float32Array(3)){return Fr(t,e)}static create(){return vr()}static translate(e,t,n=new Float32Array(16)){return Sr(n,e,t)}static getScaling(e,t=new Float32Array(3)){return Nt(t,e)}static getRotation(e,t=new Float32Array(4)){return Lr(t,e)}static copy(e,t=new Float32Array(16)){return Ar(t,e)}static fromQuat(e,t=new Float32Array(16)){return Or(t,e)}static fromRotationTranslationScale(e,t,n,i=new Float32Array(16)){return Pr(i,e,t,n)}static fromRotation(e,t,n=new Float32Array(16)){return Nr(n,e,t)}static fromScaling(e,t=new Float32Array(16)){return Ir(t,e)}static fromTranslation(e,t=new Float32Array(16)){return Cr(t,e)}static multiply(e,t,n=new Float32Array(16)){return wr(n,e,t)}static lookAt(e,t,n,i=new Float32Array(16)){return Vr(i,e,t,n)}static identity(e=new Float32Array(16)){return It(e)}static perspective(e,t,n,i,a=new Float32Array(16)){return Dr(a,e,t,n,i)}static ortho(e,t,n,i,a,s,o=new Float32Array(16)){return Gr(o,e,t,n,i,a,s)}static invert(e,t=new Float32Array(16)){return xr(t,e)}static transpose(e,t=new Float32Array(16)){return Tr(t,e)}static targetTo(e,t,n,i=new Float32Array(16)){return Hr(i,e,t,n)}static rotateX(e,t,n=new Float32Array(16)){return br(n,e,t)}static rotateY(e,t,n=new Float32Array(16)){return Mr(n,e,t)}static rotateZ(e,t,n=new Float32Array(16)){return Rr(n,e,t)}static rotate(e,t,n,i=new Float32Array(16)){return Er(i,e,t,n)}static scale(e,t,n=new Float32Array(16)){return yr(n,e,t)}}class ${constructor(e,t,n){this._parent=e,this._data=t,this._update=n}get data(){return this._id!==this._parent.transformId&&(this._update(this._data),this._id=this._parent.transformId),this._data}}const U=new Float32Array(16);class I extends H.Matrix{constructor(e){super(),this._transformId=0,e?this.array=new Float32Array(e):this.array=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}get transformId(){return this._transformId}toArray(e,t){return e?T.transpose(this.array,t):t?T.copy(this.array,t):this.array}get position(){return this._position||(this._position=new $(this,new b,e=>{T.getTranslation(this.array,e.array)})),this._position.data}get scaling(){return this._scaling||(this._scaling=new $(this,new b,e=>{T.getScaling(this.array,e.array)})),this._scaling.data}get rotation(){if(!this._rotation){let e=new Float32Array(16);this._rotation=new $(this,new X,t=>{for(let n=0;n<3;n++)e[n+0]=this.array[n+0]/this.scaling.x,e[n+4]=this.array[n+4]/this.scaling.y,e[n+8]=this.array[n+8]/this.scaling.z;D.normalize(T.getRotation(e,t.array),t.array)})}return this._rotation.data}get up(){return this._up||(this._up=new $(this,new b,e=>{x.normalize(x.set(this.array[4],this.array[5],this.array[6],e.array),e.array)})),this._up.data}get down(){return this._down||(this._down=new $(this,new b,e=>{x.negate(this.up.array,e.array)})),this._down.data}get right(){return this._right||(this._right=new $(this,new b,e=>{x.negate(this.left.array,e.array)})),this._right.data}get left(){return this._left||(this._left=new $(this,new b,e=>{x.normalize(x.cross(this.up.array,this.forward.array,e.array),e.array)})),this._left.data}get forward(){return this._forward||(this._forward=new $(this,new b,e=>{x.normalize(x.set(this.array[8],this.array[9],this.array[10],e.array),e.array)})),this._forward.data}get backward(){return this._backward||(this._backward=new $(this,new b,e=>{x.negate(this.forward.array,e.array)})),this._backward.data}copyFrom(e){return e instanceof I&&(T.copy(e.array,this.array),this._transformId++),this}setFrom(e){return T.copy(e,this.array),this._transformId++,this}setFromRotationPositionScale(e,t,n){T.fromRotationTranslationScale(e.array,t.array,n.array,this.array),this._transformId++}multiply(e){T.multiply(e.array,this.array,this.array),this._transformId++}static translate(e,t,n=new I){return n.setFrom(T.translate(e.array,t.array,U))}static fromQuaternion(e,t=new I){return t.setFrom(T.fromQuat(e.array,U))}static fromRotationTranslationScale(e,t,n,i=new I){return i.setFrom(T.fromRotationTranslationScale(e.array,t.array,n.array,U))}static fromRotation(e,t,n=new I){return n.setFrom(T.fromRotation(e,t.array,U))}static fromScaling(e,t=new I){return t.setFrom(T.fromScaling(e.array,U))}static fromTranslation(e,t=new I){return t.setFrom(T.fromTranslation(e.array,U))}static lookAt(e,t,n,i=new I){return i.setFrom(T.lookAt(e.array,t.array,n.array,U))}static identity(e=new I){return e.setFrom(T.identity(U))}static perspective(e,t,n,i,a=new I){return a.setFrom(T.perspective(e,t,n,i,U))}static ortho(e,t,n,i,a,s,o=new I){return o.setFrom(T.ortho(e,t,n,i,a,s,U))}static invert(e,t=new I){return t.setFrom(T.invert(e.array,U))}static transpose(e,t=new I){return t.setFrom(T.transpose(e.array,U))}static targetTo(e,t,n,i=new I){return i.setFrom(T.targetTo(e.array,t.array,n.array,U))}static rotateX(e,t,n=new I){return n.setFrom(T.rotateX(e.array,t,U))}static rotateY(e,t,n=new I){return n.setFrom(T.rotateY(e.array,t,U))}static rotateZ(e,t,n=new I){return n.setFrom(T.rotateZ(e.array,t,U))}static rotate(e,t,n,i=new I){return i.setFrom(T.rotate(e.array,t,n.array,U))}static scale(e,t,n=new I){return n.setFrom(T.scale(e.array,t.array,U))}}const te=new Float32Array(3);class b extends H.ObservablePoint{constructor(e=0,t=0,n=0,i=()=>{},a=void 0){super(i,a),this._array=new Float32Array(3),this._array.set([e,t,n])}get array(){return this._array}set array(e){this.setFrom(e)}get x(){return this._array[0]}set x(e){this._array[0]!==e&&(this._array[0]=e,this.cb.call(this.scope))}get y(){return this._array[1]}set y(e){this._array[1]!==e&&(this._array[1]=e,this.cb.call(this.scope))}get z(){return this._array[2]}set z(e){this._array[2]!==e&&(this._array[2]=e,this.cb.call(this.scope))}clone(e=this.cb,t=this.scope){return new b(this.x,this.y,this.z,e,t)}copyFrom(e){return(this._array[0]!==e.x||this._array[1]!==e.y||this._array[2]!==e.z)&&(this._array[0]=e.x,this._array[1]=e.y,this._array[2]=e.z,this.cb.call(this.scope)),this}copyTo(e){return e instanceof b&&e.set(this.x,this.y,this.z),e}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}set(e,t=e,n=e){return(this._array[0]!==e||this._array[1]!==t||this._array[2]!==n)&&(this._array[0]=e,this._array[1]=t,this._array[2]=n,this.cb.call(this.scope)),this}setFrom(e){return this.set(e[0],e[1],e[2]),this}normalize(e=new b){return e.setFrom(x.normalize(this._array,te))}get magnitude(){return x.magnitude(this._array)}static dot(e,t){return x.dot(e._array,t._array)}static add(e,t,n=new b){return n.setFrom(x.add(e._array,t._array,te))}static subtract(e,t,n=new b){return n.setFrom(x.subtract(e._array,t._array,te))}static cross(e,t,n=new b){return n.setFrom(x.cross(e._array,t._array,te))}static inverse(e,t=new b){return t.setFrom(x.inverse(e._array,te))}static distance(e,t){return x.distance(e._array,t._array)}static squaredDistance(e,t){return x.squaredDistance(e._array,t._array)}static multiply(e,t,n=new b){return n.setFrom(x.multiply(e._array,t._array,te))}static negate(e,t=new b){return t.setFrom(x.negate(e._array,te))}static transform(e,t,n=new b){return t instanceof I?n.setFrom(x.transformMat4(e._array,t.array,te)):n.setFrom(x.transformQuat(e._array,t.array,te))}static lerp(e,t,n,i=new b){return i.setFrom(x.lerp(e._array,t._array,n,te))}static scale(e,t,n=new b){return n.setFrom(x.scale(e._array,t,te))}}class Oe extends H.Transform{constructor(){super(...arguments),this.position=new b(0,0,0,this.onChange,this),this.scale=new b(1,1,1,this.onChange,this),this.rotationQuaternion=new X(0,0,0,1,this.onChange,this),this.worldTransform=new I,this.localTransform=new I,this.inverseWorldTransform=new I,this.normalTransform=new I}updateLocalTransform(){this._localID!==this._currentLocalID&&(this.localTransform.setFromRotationPositionScale(this.rotationQuaternion,this.position,this.scale),this._parentID=-1,this._currentLocalID=this._localID)}setFromMatrix(e){this.localTransform.copyFrom(e),this.position.copyFrom(this.localTransform.position),this.scale.copyFrom(this.localTransform.scaling),this.rotationQuaternion.copyFrom(this.localTransform.rotation)}updateTransform(e){this.updateLocalTransform(),!(e&&this._parentID===e._worldID)&&(this.worldTransform.copyFrom(this.localTransform),e instanceof Oe&&this.worldTransform.multiply(e.worldTransform),T.invert(this.worldTransform.array,this.inverseWorldTransform.array),T.transpose(this.inverseWorldTransform.array,this.normalTransform.array),this._worldID++,e&&(this._parentID=e._worldID))}lookAt(e,t=new b(0,1,0)){t instanceof b&&(t=t.array);let n=T.getRotation(T.targetTo(e.array,this.worldTransform.position.array,t));this.rotationQuaternion.set(n[0],n[1],n[2],n[3])}}class J extends ar.Container{constructor(){super(...arguments),this.transform=new Oe}set position(e){this.transform.position.copyFrom(e)}get position(){return this.transform.position}set scale(e){this.transform.scale.copyFrom(e)}get scale(){return this.transform.scale}set rotationQuaternion(e){this.transform.rotationQuaternion.copyFrom(e)}get rotationQuaternion(){return this.transform.rotationQuaternion}get z(){return this.transform.position.z}set z(e){this.transform.position.z=e}get localTransform(){return this.transform.localTransform}get worldTransform(){return this.transform.worldTransform}}class Ze{constructor(e,t){this._direction=new b,this._origin=new b,this._origin.copyFrom(e),this._direction.copyFrom(t)}get origin(){return this._origin}get direction(){return this._direction}getPoint(e,t=new b){return b.add(this._origin,b.scale(this._direction,e,t),t)}}class Me{static set(e,t,n,i,a=new Float32Array(4)){return Ut(a,e,t,n,i)}static transformMat4(e,t,n=new Float32Array(4)){return sn(n,e,t)}static fromValues(e,t,n,i){return Ot(e,t,n,i)}}const pn=new Float32Array(3),vn=new Float32Array(16),Re=new Float32Array(4);class k extends J{constructor(e){super(),this.renderer=e,this._transformId=0,this._orthographic=!1,this._orthographicSize=10,this._obliqueness=new H.ObservablePoint(()=>{this._transformId++},void 0),this._fieldOfView=60,this._near=.1,this._far=1e3;let t=e.width/e.height,n=-1;this.renderer.on("prerender",()=>{this._aspect||e.width/e.height!==t&&(this._transformId++,t=e.width/e.height),!this.parent&&n!==this.transform._localID&&(this.transform.updateTransform(),n=this.transform._localID)}),k.main||(k.main=this),this.transform.position.z=5,this.transform.rotationQuaternion.setEulerAngles(0,180,0)}get transformId(){return this.transform._worldID+this._transformId}get obliqueness(){return this._obliqueness}set obliqueness(e){this._obliqueness.copyFrom(e)}destroy(e){super.destroy(e),this===k.main&&(k.main=void 0)}get orthographicSize(){return this._orthographicSize}set orthographicSize(e){this._orthographicSize!==e&&(this._orthographicSize=e,this._transformId++)}get orthographic(){return this._orthographic}set orthographic(e){this._orthographic!==e&&(this._orthographic=e,this._transformId++)}screenToRay(e,t,n=this.renderer.screen){let i=this.screenToWorld(e,t,1,void 0,n);if(i)return this.orthographic?new Ze(i,this.worldTransform.forward):new Ze(this.worldTransform.position,b.subtract(i,this.worldTransform.position))}screenToWorld(e,t,n,i=new b,a=this.renderer.screen){var s;this.transform.updateTransform((s=this.parent)==null?void 0:s.transform);let o=this.far;this.far=n;let h=T.invert(this.viewProjection.array,vn);if(h===null)return;let l=Me.set(e/a.width*2-1,(t/a.height*2-1)*-1,1,1,Re);this.far=o;let u=Me.transformMat4(l,h,Re);u[3]=1/u[3];for(let d=0;d<3;d++)u[d]*=u[3];return i.set(u[0],u[1],u[2])}worldToScreen(e,t,n,i=new H.Point,a=this.renderer.screen){var s;this.transform.updateTransform((s=this.parent)==null?void 0:s.transform);let o=Me.set(e,t,n,1,Re),h=Me.transformMat4(Me.transformMat4(o,this.view.array,Re),this.projection.array,Re);if(h[3]!==0)for(let l=0;l<3;l++)h[l]/=h[3];return i.set((h[0]+1)/2*a.width,a.height-(h[1]+1)/2*a.height)}get aspect(){return this._aspect}set aspect(e){this._aspect!==e&&(this._aspect=e,this._transformId++)}get fieldOfView(){return this._fieldOfView}set fieldOfView(e){this._fieldOfView!==e&&(this._fieldOfView=e,this._transformId++)}get near(){return this._near}set near(e){this._near!==e&&(this._near=e,this._transformId++)}get far(){return this._far}set far(e){this._far!==e&&(this._far=e,this._transformId++)}get projection(){return this._projection||(this._projection=new $(this,new I,e=>{const t=this._aspect||this.renderer.width/this.renderer.height;this._orthographic?T.ortho(-this._orthographicSize*t,this._orthographicSize*t,-this._orthographicSize,this._orthographicSize,this._near,this._far,e.array):(T.perspective(this._fieldOfView*H.DEG_TO_RAD,t,this._near,this._far,e.array),e.array[8]=this._obliqueness.x,e.array[9]=this._obliqueness.y)})),this._projection.data}get view(){return this._view||(this._view=new $(this,new I,e=>{const t=x.add(this.worldTransform.position.array,this.worldTransform.forward.array,pn);T.lookAt(this.worldTransform.position.array,t,this.worldTransform.up.array,e.array)})),this._view.data}get viewProjection(){return this._viewProjection||(this._viewProjection=new $(this,new I,e=>{T.multiply(this.projection.array,this.view.array,e.array)})),this._viewProjection.data}}N.installRendererPlugin("camera",k);class An{constructor(e,t=k.main){this._autoUpdate=!0,this._allowControl=!0,this._camera=k.main,this._target={x:0,y:0,z:0},this._angles=new H.ObservablePoint(()=>{this._angles.x=Math.min(Math.max(-85,this._angles.x),85)},void 0,0,180),this._distance=5,this._enableDamping=!1,this._dampingFactor=.1,this._grabbed=!1,this._previousPinchDistance=0,this._previousClientX=0,this._previousClientY=0,this._dampingAngles={x:0,y:180},this._dampingDistance=5,this.onPointerDown=(n,i)=>{this._grabbed=!0,this._previousClientX=n,this._previousClientY=i},this.onPointerUp=()=>{this._grabbed=!1},this.onPointerMove=(n,i)=>{if(this._grabbed){const a=n-this._previousClientX,s=i-this._previousClientY;this.angles.x+=s*.5,this.angles.y-=a*.5,this.updateCamera(),this._previousClientX=n,this._previousClientY=i}},this.onPreRender=()=>{this.autoUpdate&&this.updateCamera()},this.onMouseDownInteraction=n=>{var i,a,s;if(this.allowControl&&!n.stopped){this._grabbed=!0;const o=n.data.originalEvent,h=o,l=o,u=(i=h==null?void 0:h.targetTouches)==null?void 0:i[0],d=(a=u==null?void 0:u.clientX)!=null?a:l==null?void 0:l.clientX,c=(s=u==null?void 0:u.clientY)!=null?s:l==null?void 0:l.clientY;this.onPointerDown(d,c)}},this.onMouseDown=n=>{this.allowControl&&this.onPointerDown(n.clientX,n.clientY)},this.onMouseMove=n=>{this.allowControl&&n.buttons===1&&this.onPointerMove(n.clientX,n.clientY)},this.onMouseUp=n=>{this.allowControl&&this.onPointerUp()},this.onWheel=n=>{this.allowControl&&(this.distance+=n.deltaY*.01,n.preventDefault(),this.updateCamera())},this.onTouchStart=n=>{var i;if(this.allowControl){const a=(i=n==null?void 0:n.targetTouches)==null?void 0:i[0];if(a){const s=a.clientX,o=a.clientY;this.onPointerDown(s,o)}n.touches.length===2&&(n.preventDefault(),this._previousPinchDistance=Math.hypot(n.touches[0].clientX-n.touches[1].clientX,n.touches[0].clientY-n.touches[1].clientY))}},this.onPinch=n=>{if(this.allowControl){n.preventDefault();const i=Math.hypot(n.touches[0].clientX-n.touches[1].clientX,n.touches[0].clientY-n.touches[1].clientY),a=i-this._previousPinchDistance;this.distance-=a*.1,this.updateCamera(),this._previousPinchDistance=i}},this.onTouchMove=n=>{var i;if(this.allowControl){const a=(i=n==null?void 0:n.targetTouches)==null?void 0:i[0];if(n.touches.length===1&&a){const s=a.clientX,o=a.clientY;this.onPointerMove(s,o)}n.touches.length===2&&this.onPinch(n)}},this.onTouchEnd=n=>{this.allowControl&&n.touches.length===0&&this.onPointerUp()},this._element=e,this._camera=t,this.bind()}get autoUpdate(){return this._autoUpdate}set autoUpdate(e){this._autoUpdate=e}get allowControl(){return this._allowControl}set allowControl(e){this._allowControl=e}get camera(){return this._camera}set camera(e){this._camera=e}get target(){return this._target}set target(e){this._target=e}get angles(){return this._angles}get distance(){return this._distance}set distance(e){this._distance=Math.min(Math.max(e,.01),Number.MAX_SAFE_INTEGER)}get enableDamping(){return this._enableDamping}set enableDamping(e){this._enableDamping=e}get dampingFactor(){return this._dampingFactor}set dampingFactor(e){this._dampingFactor=e}destroy(){this.unbind()}bind(){this.camera.renderer.on("prerender",this.onPreRender);let e=N.getInteractionPlugin(this.camera.renderer);e&&e.on("mousedown",this.onMouseDownInteraction),this._element.addEventListener("mousedown",this.onMouseDown),this._element.addEventListener("touchstart",this.onTouchStart),this._element.addEventListener("wheel",this.onWheel),window.addEventListener("mousemove",this.onMouseMove),window.addEventListener("touchmove",this.onTouchMove),window.addEventListener("mouseup",this.onMouseUp),window.addEventListener("touchend",this.onTouchEnd)}unbind(){this._element.removeEventListener("mousedown",this.onMouseDown),this._element.removeEventListener("touchstart",this.onTouchStart),this._element.removeEventListener("wheel",this.onWheel),window.removeEventListener("mousemove",this.onMouseMove),window.removeEventListener("touchmove",this.onTouchMove),window.removeEventListener("mouseup",this.onMouseUp),window.removeEventListener("touchend",this.onTouchEnd)}updateCamera(){this.enableDamping&&(this._dampingAngles.x+=(this.angles.x-this._dampingAngles.x)*this.dampingFactor,this._dampingAngles.y+=(this.angles.y-this._dampingAngles.y)*this.dampingFactor,this._dampingDistance+=(this.distance-this._dampingDistance)*this.dampingFactor);const e=this.enableDamping?this._dampingAngles:this.angles,t=this.enableDamping?this._dampingDistance:this.distance,n=D.fromEuler(e.x,e.y,0,new Float32Array(4)),i=x.transformQuat(x.set(0,0,1,new Float32Array(3)),n,new Float32Array(3)),a=x.subtract(x.set(this.target.x,this.target.y,this.target.z,new Float32Array(3)),x.scale(i,t,new Float32Array(3)),new Float32Array(3));this.camera.position.set(a[0],a[1],a[2]),this.camera.rotationQuaternion.set(n[0],n[1],n[2],n[3])}}class ce{constructor(){this._shaderGeometry={}}getShaderGeometry(e){return this._shaderGeometry[e.name]}addShaderGeometry(e,t){this._shaderGeometry[e.name]=e.createShaderGeometry(this,t)}hasShaderGeometry(e,t){return this._shaderGeometry[e.name]?!t||t&&this._shaderGeometry[e.name].instanced:!1}destroy(){for(let e in this._shaderGeometry)this._shaderGeometry[e].destroy();this._shaderGeometry={}}}var $e;(r=>{function e(){return Object.assign(new ce,{positions:{buffer:new Float32Array([-1,0,1,1,0,-1,-1,0,-1,1,0,1])},indices:{buffer:new Uint8Array([0,1,2,0,3,1])},normals:{buffer:new Float32Array([0,1,0,0,1,0,0,1,0,0,1,0])},uvs:[{buffer:new Float32Array([0,1,1,0,0,0,1,1])}]})}r.create=e})($e||($e={}));var et;(r=>{function e(){return Object.assign(new ce,{positions:{buffer:new Float32Array([-1,1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,1,-1,1,1,-1,1,-1,1,1,-1,-1,1,1,1,1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,1,-1,1,1,1,1,-1,-1,1,-1,1,1,1])},indices:{buffer:new Uint8Array([0,1,2,0,3,1,4,5,6,4,7,5,8,9,10,8,11,9,12,13,14,12,15,13,16,17,18,16,19,17,20,21,22,20,23,21])},normals:{buffer:new Float32Array([-1,0,0,-1,0,0,-1,0,0,-1,0,0,0,0,-1,0,0,-1,0,0,-1,0,0,-1,1,0,0,1,0,0,1,0,0,1,0,0,0,0,1,0,0,1,0,0,1,0,0,1,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,1,0,0,1,0,0,1,0,0,1,0])},uvs:[{buffer:new Float32Array([.625,1,.375,.75,.375,1,.625,.75,.625,.75,.375,.5,.375,.75,.625,.5,.625,.5,.375,.25,.375,.5,.625,.25,.625,.25,.375,0,.375,.25,.625,0,.375,.25,.125,.5,.375,.5,.125,.25,.875,.25,.625,.5,.875,.5,.625,.25])}],tangents:{buffer:new Float32Array([0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,-1,0,0,1,-1,0,0,1,-1,0,0,1,-1,0,0,1])}})}r.create=e})(et||(et={}));var tt;(r=>{function e(){return Object.assign(new ce,{positions:{buffer:new Float32Array([-1,1,0,1,-1,0,-1,-1,0,1,1,0])},indices:{buffer:new Uint8Array([0,2,1,0,1,3])},normals:{buffer:new Float32Array([0,0,1,0,0,1,0,0,1,0,0,1])},uvs:[{buffer:new Float32Array([0,0,1,1,0,1,1,0])}]})}r.create=e})(tt||(tt={}));class Tn extends J{constructor(e,t){super(),this.mesh=e,this.material=t}destroy(e){super.destroy(e),this.mesh.removeInstance(this)}}var re=(r=>(r.spot="spot",r.directional="directional",r.point="point",r))(re||{}),oe=(r=>(r.opaque="opaque",r.mask="mask",r.blend="blend",r))(oe||{}),le=(r=>(r.alpha="alpha",r.emissive="emissive",r.f0="f0",r.metallic="metallic",r.normal="normal",r.occlusion="occlusion",r.roughness="roughness",r))(le||{}),ee;(r=>{let e;function t(_){if(e!==void 0)return e;const m=_.gl;return e=m.getParameter(m.MAX_VERTEX_UNIFORM_VECTORS),e}r.getMaxVertexUniformVectors=t;let n;function i(_){return _.context.webGLVersion===2?!0:(n!==void 0||(n=!!_.gl.getExtension("OES_texture_float")),n)}r.isFloatingPointTextureSupported=i;let a;function s(_){if(_.context.webGLVersion===2)return!0;if(a!==void 0)return a;const m=_.gl,g=m.getExtension("OES_texture_half_float");if(!g)return!1;const A=m.createTexture();m.bindTexture(m.TEXTURE_2D,A),m.texImage2D(m.TEXTURE_2D,0,m.RGBA,8,8,0,m.RGBA,g.HALF_FLOAT_OES,null);const M=m.createFramebuffer();m.bindFramebuffer(m.FRAMEBUFFER,M);const w=m.COLOR_ATTACHMENT0;return m.framebufferTexture2D(m.FRAMEBUFFER,w,m.TEXTURE_2D,A,0),a=m.checkFramebufferStatus(m.FRAMEBUFFER)===m.FRAMEBUFFER_COMPLETE,a}r.isHalfFloatFramebufferSupported=s;let o;function h(_){if(_.context.webGLVersion===2)return!0;if(o!==void 0)return o;const m=_.gl;if(!m.getExtension("OES_texture_float"))return!1;const g=m.createTexture();m.bindTexture(m.TEXTURE_2D,g),m.texImage2D(m.TEXTURE_2D,0,m.RGBA,8,8,0,m.RGBA,m.FLOAT,null);const A=m.createFramebuffer();m.bindFramebuffer(m.FRAMEBUFFER,A);const M=m.COLOR_ATTACHMENT0;return m.framebufferTexture2D(m.FRAMEBUFFER,M,m.TEXTURE_2D,g,0),o=m.checkFramebufferStatus(m.FRAMEBUFFER)===m.FRAMEBUFFER_COMPLETE,o}r.isFloatFramebufferSupported=h;let l;function u(_){return l!==void 0||(l=_.gl.getExtension("OES_texture_float_linear")!==null),l}r.supportsFloatLinear=u;function d(_){return _.context.webGLVersion===2?!0:_.gl.getExtension("EXT_shader_texture_lod")!==null}r.isShaderTextureLodSupported=d;let c;function f(_){return c!==void 0||(c=_.gl.getExtension("ANGLE_instanced_arrays")!==void 0),c}r.isInstancingSupported=f})(ee||(ee={}));const rt=O.get(P,"BufferResource")||O.get(P,"resources").BufferResource;class we extends p.Texture{constructor(e){let t=new Float32Array(e*16),n=new rt(t,{width:4,height:e});super(new p.BaseTexture(n,{mipmap:C.MIPMAP_MODES.OFF,wrapMode:C.WRAP_MODES.CLAMP,scaleMode:C.SCALE_MODES.NEAREST,format:C.FORMATS.RGBA,type:C.TYPES.FLOAT,alphaMode:C.ALPHA_MODES.NO_PREMULTIPLIED_ALPHA,resolution:1})),this._buffer=t}static isSupported(e){return ee.isFloatingPointTextureSupported(e)}updateBuffer(e){this._buffer.set(e),this.baseTexture.resource.update()}}v.Debug=void 0,(r=>{const e=[],t=new Xe.EventEmitter;function n(o,h,l){t.on(o,h,l)}r.on=n;function i(o,h){if(!e.includes(o)){e.push(o);let l=s(o,h);console.warn(`PIXI3D: ${l}`),t.emit("warn",l)}}r.warn=i;function a(o,h){if(!e.includes(o)){e.push(o);let l=s(o,h);console.error(`PIXI3D: ${l}`),t.emit("error",l)}}r.error=a;function s(o,h){let l=o,u;for(;(u=/{(\w*)}/g.exec(l))!==null&&h;)l=l.replace(u[0],h[u[1]]);return l}})(v.Debug||(v.Debug={}));var ve=(r=>(r.meshVertexSkinningFloatingPointTexturesNotSupported='Mesh is using vertex skinning but floating point textures is not supported on this device/environment. In case of errors, try changing the environment in PixiJS settings. Set "PIXI.settings.PREFER_ENV = PIXI.ENV.WEBGL2" before creating a renderer/application.',r.meshVertexSkinningNumberOfJointsNotSupported="Mesh is using vertex skinning but the number of joints ({joints}) is not supported on this device/environment. Max number of supported joints is {maxJoints}, try reducing the number of joints.",r.imageBasedLightingShaderTextureLodNotSupported='Image based lighting is used but shader texture lod is not supported on this device/environment, the material may not be displayed correctly. Try changing the environment in PixiJS settings. Set "PIXI.settings.PREFER_ENV = PIXI.ENV.WEBGL2" before creating a renderer/application.',r))(ve||{}),Se=(r=>(r.ldr="ldr",r.rgbe8="rgbe8",r))(Se||{}),Ue;(r=>{function e(i,a,s,o,h){let l=[];if(a.instances.length>0&&l.push("USE_INSTANCING 1"),i.context.webGLVersion===1&&l.push("WEBGL1 1"),i.context.webGLVersion===2&&l.push("WEBGL2 1"),s.colors&&(s.colors.componentCount===3?l.push("HAS_VERTEX_COLOR_VEC3 1"):l.push("HAS_VERTEX_COLOR_VEC4 1")),s.normals&&l.push("HAS_NORMALS 1"),s.uvs&&s.uvs[0]&&l.push("HAS_UV_SET1 1"),s.uvs&&s.uvs[1]&&l.push("HAS_UV_SET2 1"),s.tangents&&l.push("HAS_TANGENTS 1"),s.targets){for(let u=0;u<s.targets.length;u++)s.targets[u].positions&&l.push("HAS_TARGET_POSITION"+u),s.targets[u].normals&&l.push("HAS_TARGET_NORMAL"+u),s.targets[u].tangents&&l.push("HAS_TARGET_TANGENT"+u);a.targetWeights&&a.targetWeights.length>0&&(l.push(`WEIGHT_COUNT ${a.targetWeights.length}`),l.push("USE_MORPHING 1"))}if(s.joints&&l.push("HAS_JOINT_SET1 1"),s.weights&&l.push("HAS_WEIGHT_SET1 1"),a.skin&&t(a,l,i),o.unlit&&l.push("MATERIAL_UNLIT 1"),l.push("MATERIAL_METALLICROUGHNESS 1"),h.fog&&l.push("USE_FOG 1"),h.lights.length>0&&(l.push(`LIGHT_COUNT ${h.lights.length}`),l.push("USE_PUNCTUAL 1")),h.imageBasedLighting){if(!h.imageBasedLighting.valid)return;ee.isShaderTextureLodSupported(i)?l.push("USE_TEX_LOD 1"):v.Debug.warn(ve.imageBasedLightingShaderTextureLodNotSupported),l.push("USE_IBL 1"),h.imageBasedLighting.diffuse.cubemapFormat===Se.rgbe8&&l.push("USE_RGBE 1")}if(o.shadowCastingLight&&l.push("USE_SHADOW_MAPPING 1"),o.baseColorTexture){if(!o.baseColorTexture.valid)return;o.baseColorTexture.transform&&l.push("HAS_BASECOLOR_UV_TRANSFORM 1"),l.push("HAS_BASE_COLOR_MAP 1")}if(o.emissiveTexture){if(!o.emissiveTexture.valid)return;o.emissiveTexture.transform&&l.push("HAS_EMISSIVE_UV_TRANSFORM 1"),l.push("HAS_EMISSIVE_MAP 1")}if(o.normalTexture){if(!o.normalTexture.valid)return;o.normalTexture.transform&&l.push("HAS_NORMAL_UV_TRANSFORM 1"),l.push("HAS_NORMAL_MAP 1")}if(o.metallicRoughnessTexture){if(!o.metallicRoughnessTexture.valid)return;o.metallicRoughnessTexture.transform&&l.push("HAS_METALLICROUGHNESS_UV_TRANSFORM 1"),l.push("HAS_METALLIC_ROUGHNESS_MAP 1")}if(o.occlusionTexture){if(!o.occlusionTexture.valid)return;o.occlusionTexture.transform&&l.push("HAS_OCCLUSION_UV_TRANSFORM 1"),l.push("HAS_OCCLUSION_MAP 1")}switch(o.alphaMode){case oe.opaque:{l.push("ALPHAMODE_OPAQUE 1");break}case oe.mask:{l.push("ALPHAMODE_MASK 1");break}}switch(o.debugMode&&l.push("DEBUG_OUTPUT 1"),o.debugMode){case le.alpha:{l.push("DEBUG_ALPHA 1");break}case le.emissive:{l.push("DEBUG_EMISSIVE 1");break}case le.f0:{l.push("DEBUG_F0 1");break}case le.metallic:{l.push("DEBUG_METALLIC 1");break}case le.normal:{l.push("DEBUG_NORMAL 1");break}case le.occlusion:{l.push("DEBUG_OCCLUSION 1");break}case le.roughness:{l.push("DEBUG_ROUGHNESS 1");break}}return l}r.build=e;function t(i,a,s){if(!i.skin)return;let o=20,h=ee.getMaxVertexUniformVectors(s)-o,l=Math.floor(h/8),u=i.skin.joints.length<=l;const d=()=>{var f;a.push("USE_SKINNING 1"),a.push(`JOINT_COUNT ${(f=i.skin)==null?void 0:f.joints.length}`)},c=()=>{var f;a.push("USE_SKINNING 1"),a.push(`JOINT_COUNT ${(f=i.skin)==null?void 0:f.joints.length}`),a.push("USE_SKINNING_TEXTURE 1")};if(Te.settings.PREFER_UNIFORMS_WHEN_UPLOADING_SKIN_JOINTS){if(u){d();return}if(we.isSupported(s)){c();return}else v.Debug.error(ve.meshVertexSkinningNumberOfJointsNotSupported,{joints:i.skin.joints.length,maxJoints:l})}else{if(we.isSupported(s)){c();return}v.Debug.warn(ve.meshVertexSkinningFloatingPointTexturesNotSupported),u?d():v.Debug.error(ve.meshVertexSkinningNumberOfJointsNotSupported,{joints:i.skin.joints.length,maxJoints:l})}}function n(i){return i.includes("USE_SKINNING_TEXTURE 1")}r.hasSkinningTextureFeature=n})(Ue||(Ue={}));class Ae extends p.Shader{constructor(){super(...arguments),this._state=Object.assign(new p.State,{culling:!0,clockwiseFrontFace:!1,depthTest:!0})}get name(){return"mesh-shader"}createShaderGeometry(e,t){let n=new p.Geometry;return e.indices&&(e.indices.buffer.BYTES_PER_ELEMENT===1?n.addIndex(new p.Buffer(new Uint16Array(e.indices.buffer))):n.addIndex(new p.Buffer(e.indices.buffer))),e.positions&&n.addAttribute("a_Position",new p.Buffer(e.positions.buffer),3,e.positions.normalized,e.positions.componentType,e.positions.stride),e.uvs&&e.uvs[0]&&n.addAttribute("a_UV1",new p.Buffer(e.uvs[0].buffer),2,e.uvs[0].normalized,e.uvs[0].componentType,e.uvs[0].stride),e.normals&&n.addAttribute("a_Normal",new p.Buffer(e.normals.buffer),3,e.normals.normalized,e.normals.componentType,e.normals.stride),e.tangents&&n.addAttribute("a_Tangent",new p.Buffer(e.tangents.buffer),4,e.tangents.normalized,e.tangents.componentType,e.tangents.stride),e.colors&&n.addAttribute("a_Color",new p.Buffer(e.colors.buffer),e.colors.componentCount,e.colors.normalized,e.colors.componentType,e.colors.stride),n}render(e,t,n=this._state,i=C.DRAW_MODES.TRIANGLES){const a=e.instances.filter(h=>h.worldVisible&&h.renderable).length,s=e.instances.length>0;e.geometry.hasShaderGeometry(this,s)||e.geometry.addShaderGeometry(this,s);let o=e.geometry.getShaderGeometry(this);t.shader.bind(this,!1),t.state.set(n),t.geometry.bind(o,this),t.geometry.draw(i,void 0,void 0,a)}}class xn{constructor(){this._maxInstances=200,this._modelMatrix=[new p.Buffer,new p.Buffer,new p.Buffer,new p.Buffer],this._normalMatrix=[new p.Buffer,new p.Buffer,new p.Buffer,new p.Buffer],this._baseColor=new p.Buffer,this.expandBuffers(this._maxInstances)}expandBuffers(e){for(;e>this._maxInstances;)this._maxInstances+=Math.floor(this._maxInstances*.5);for(let t=0;t<4;t++)this._modelMatrix[t].update(new Float32Array(4*this._maxInstances)),this._normalMatrix[t].update(new Float32Array(4*this._maxInstances));this._baseColor.update(new Float32Array(4*this._maxInstances))}updateBuffers(e){e.length>this._maxInstances&&this.expandBuffers(e.length);let t=0;for(let n=0;n<e.length;n++){const i=e[n].transform.normalTransform.array;for(let o=0;o<4;o++)this._normalMatrix[o].data.set(i.slice(o*4,o*4+4),t*4);const a=e[n].worldTransform.array;for(let o=0;o<4;o++)this._modelMatrix[o].data.set(a.slice(o*4,o*4+4),t*4);const s=e[n].material;this._baseColor.data.set(s.baseColor.rgba,t*4),t++}for(let n=0;n<4;n++)this._modelMatrix[n].update(),this._normalMatrix[n].update();this._baseColor.update()}addGeometryAttributes(e){for(let t=0;t<4;t++)e.addAttribute(`a_ModelMatrix${t}`,this._modelMatrix[t],4,!1,void 0,0,void 0,!0);for(let t=0;t<4;t++)e.addAttribute(`a_NormalMatrix${t}`,this._normalMatrix[t],4,!1,void 0,0,void 0,!0);e.addAttribute("a_BaseColorFactor",this._baseColor,4,!1,void 0,0,void 0,!0)}}var de;(r=>{function e(t,n,i){return i.context.webGLVersion===1&&(t=t.replace(/VERSION/,"100").replace(/VERT_IN/g,"attribute").replace(/VERT_OUT/g,"varying").replace(/FRAG_COLOR/g,"gl_FragColor").replace(/FRAG_IN/g,"varying")),i.context.webGLVersion===2&&(t=t.replace(/VERSION/,"300 es").replace(/VERT_IN/g,"in").replace(/VERT_OUT/g,"out").replace(/FRAG_COLOR/g,"g_finalColor").replace(/FRAG_IN/g,"in")),t.replace(/#define FEATURES/,n.map(a=>`#define ${a}`).join(`
`))}r.build=e})(de||(de={}));var wn={source:`#version VERSION

//
// This fragment shader defines a reference implementation for Physically Based Shading of
// a microfacet surface material defined by a glTF model.
//
// References:
// [1] Real Shading in Unreal Engine 4
//     http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf
// [2] Physically Based Shading at Disney
//     http://blog.selfshadow.com/publications/s2012-shading-course/burley/s2012_pbs_disney_brdf_notes_v3.pdf
// [3] README.md - Environment Maps
//     https://github.com/KhronosGroup/glTF-WebGL-PBR/#environment-maps
// [4] "An Inexpensive BRDF Model for Physically based Rendering" by Christophe Schlick
//     https://www.cs.virginia.edu/~jdl/bib/appearance/analytic%20models/schlick94b.pdf

#define FEATURES

#if defined(WEBGL1) //&& defined(USE_TEX_LOD)
#extension GL_EXT_shader_texture_lod : enable
#endif

#if defined(WEBGL1)
#extension GL_OES_standard_derivatives : enable
#endif

#if defined(WEBGL1) && defined(USE_HDR)
#extension GL_OES_texture_float : enable
#extension GL_OES_texture_float_linear : enable
#endif

#ifdef GL_FRAGMENT_PRECISION_HIGH
  precision highp float;
#else
  precision mediump float;
#endif

vec4 _texture(sampler2D sampler, vec2 coord)
{
#ifdef WEBGL2
    return texture(sampler, coord);
#else
    return texture2D(sampler, coord);
#endif
}

vec4 _texture(samplerCube sampler, vec3 coord)
{
#ifdef WEBGL2
    return texture(sampler, coord);
#else
    return textureCube(sampler, coord);
#endif
}
vec4 _textureLod(sampler2D sampler, vec2 coord, float lod)
{
#ifdef WEBGL2
    return textureLod(sampler, coord, lod);
#endif
#if defined(WEBGL1) && defined(GL_EXT_shader_texture_lod) 
    return texture2DLodEXT(sampler, coord, lod);
#endif
    return vec4(0.0);
}

vec4 _textureLod(samplerCube sampler, vec3 coord, float lod)
{
#ifdef WEBGL2
    return textureLod(sampler, coord, lod);
#endif
#if defined(WEBGL1) && defined(GL_EXT_shader_texture_lod) 
    return textureCubeLodEXT(sampler, coord, lod);
#endif
    return vec4(0.0);
}
vec3 _dFdx(vec3 coord)
{
#if defined(WEBGL2) || defined(GL_OES_standard_derivatives)
    return dFdx(coord);
#endif
    return vec3(0.0);
}

vec3 _dFdy(vec3 coord)
{
#if defined(WEBGL2) || defined(GL_OES_standard_derivatives)
    return dFdy(coord);
#endif
    return vec3(0.0);
}
FRAG_IN vec2 v_UVCoord1;
FRAG_IN vec2 v_UVCoord2;

// General Material
#ifdef HAS_NORMAL_MAP
uniform sampler2D u_NormalSampler;
uniform float u_NormalScale;
uniform int u_NormalUVSet;
uniform mat3 u_NormalUVTransform;
#endif

#ifdef HAS_EMISSIVE_MAP
uniform sampler2D u_EmissiveSampler;
uniform int u_EmissiveUVSet;
uniform vec3 u_EmissiveFactor;
uniform mat3 u_EmissiveUVTransform;
#endif

#ifdef HAS_OCCLUSION_MAP
uniform sampler2D u_OcclusionSampler;
uniform int u_OcclusionUVSet;
uniform float u_OcclusionStrength;
uniform mat3 u_OcclusionUVTransform;
#endif

// Metallic Roughness Material
#ifdef HAS_BASE_COLOR_MAP
uniform sampler2D u_BaseColorSampler;
uniform int u_BaseColorUVSet;
uniform mat3 u_BaseColorUVTransform;
#endif

#ifdef HAS_METALLIC_ROUGHNESS_MAP
uniform sampler2D u_MetallicRoughnessSampler;
uniform int u_MetallicRoughnessUVSet;
uniform mat3 u_MetallicRoughnessUVTransform;
#endif

// Specular Glossiness Material
#ifdef HAS_DIFFUSE_MAP
uniform sampler2D u_DiffuseSampler;
uniform int u_DiffuseUVSet;
uniform mat3 u_DiffuseUVTransform;
#endif

#ifdef HAS_SPECULAR_GLOSSINESS_MAP
uniform sampler2D u_SpecularGlossinessSampler;
uniform int u_SpecularGlossinessUVSet;
uniform mat3 u_SpecularGlossinessUVTransform;
#endif

// IBL
#ifdef USE_IBL
uniform samplerCube u_DiffuseEnvSampler;
uniform samplerCube u_SpecularEnvSampler;
uniform sampler2D u_brdfLUT;
#endif

#ifdef USE_SHADOW_MAPPING
uniform sampler2D u_ShadowSampler;
#endif

vec2 getNormalUV()
{
    vec3 uv = vec3(v_UVCoord1, 1.0);
#ifdef HAS_NORMAL_MAP
    uv.xy = u_NormalUVSet < 1 ? v_UVCoord1 : v_UVCoord2;
    #ifdef HAS_NORMAL_UV_TRANSFORM
    uv = u_NormalUVTransform * uv;
    #endif
#endif
    return uv.xy;
}

vec2 getEmissiveUV()
{
    vec3 uv = vec3(v_UVCoord1, 1.0);
#ifdef HAS_EMISSIVE_MAP
    uv.xy = u_EmissiveUVSet < 1 ? v_UVCoord1 : v_UVCoord2;
    #ifdef HAS_EMISSIVE_UV_TRANSFORM
    uv = u_EmissiveUVTransform * uv;
    #endif
#endif

    return uv.xy;
}

vec2 getOcclusionUV()
{
    vec3 uv = vec3(v_UVCoord1, 1.0);
#ifdef HAS_OCCLUSION_MAP
    uv.xy = u_OcclusionUVSet < 1 ? v_UVCoord1 : v_UVCoord2;
    #ifdef HAS_OCCLUSION_UV_TRANSFORM
    uv = u_OcclusionUVTransform * uv;
    #endif
#endif
    return uv.xy;
}

vec2 getBaseColorUV()
{
    vec3 uv = vec3(v_UVCoord1, 1.0);
#ifdef HAS_BASE_COLOR_MAP
    uv.xy = u_BaseColorUVSet < 1 ? v_UVCoord1 : v_UVCoord2;
    #ifdef HAS_BASECOLOR_UV_TRANSFORM
    uv = u_BaseColorUVTransform * uv;
    #endif
#endif
    return uv.xy;
}

vec2 getMetallicRoughnessUV()
{
    vec3 uv = vec3(v_UVCoord1, 1.0);
#ifdef HAS_METALLIC_ROUGHNESS_MAP
    uv.xy = u_MetallicRoughnessUVSet < 1 ? v_UVCoord1 : v_UVCoord2;
    #ifdef HAS_METALLICROUGHNESS_UV_TRANSFORM
    uv = u_MetallicRoughnessUVTransform * uv;
    #endif
#endif
    return uv.xy;
}

vec2 getSpecularGlossinessUV()
{
    vec3 uv = vec3(v_UVCoord1, 1.0);
#ifdef HAS_SPECULAR_GLOSSINESS_MAP
    uv.xy = u_SpecularGlossinessUVSet < 1 ? v_UVCoord1 : v_UVCoord2;
    #ifdef HAS_SPECULARGLOSSINESS_UV_TRANSFORM
    uv = u_SpecularGlossinessUVTransform * uv;
    #endif
#endif
    return uv.xy;
}

vec2 getDiffuseUV()
{
    vec3 uv = vec3(v_UVCoord1, 1.0);
#ifdef HAS_DIFFUSE_MAP
    uv.xy = u_DiffuseUVSet < 1 ? v_UVCoord1 : v_UVCoord2;
    #ifdef HAS_DIFFUSE_UV_TRANSFORM
    uv = u_DiffuseUVTransform * uv;
    #endif
#endif
    return uv.xy;
}

// textures.glsl needs to be included

const float M_PI = 3.141592653589793;
const float c_MinReflectance = 0.04;

FRAG_IN vec3 v_Position;
FRAG_IN vec3 v_ModelViewPosition;

#ifdef HAS_NORMALS
#ifdef HAS_TANGENTS
FRAG_IN mat3 v_TBN;
#else
FRAG_IN vec3 v_Normal;
#endif
#endif

#ifdef HAS_VERTEX_COLOR_VEC3
FRAG_IN vec3 v_Color;
#endif
#ifdef HAS_VERTEX_COLOR_VEC4
FRAG_IN vec4 v_Color;
#endif

struct AngularInfo
{
    float NdotL;                  // cos angle between normal and light direction
    float NdotV;                  // cos angle between normal and view direction
    float NdotH;                  // cos angle between normal and half vector
    float LdotH;                  // cos angle between light direction and half vector

    float VdotH;                  // cos angle between view direction and half vector

    vec3 padding;
};

vec4 getVertexColor()
{
   vec4 color = vec4(1.0, 1.0, 1.0, 1.0);

#ifdef HAS_VERTEX_COLOR_VEC3
    color.rgb = v_Color;
#endif
#ifdef HAS_VERTEX_COLOR_VEC4
    color = v_Color;
#endif

   return color;
}

// Find the normal for this fragment, pulling either from a predefined normal map
// or from the interpolated mesh normal and tangent attributes.
vec3 getNormal()
{
    vec2 UV = getNormalUV();

    // Retrieve the tangent space matrix
#ifndef HAS_TANGENTS
    vec3 pos_dx = _dFdx(v_Position);
    vec3 pos_dy = _dFdy(v_Position);
    vec3 tex_dx = _dFdx(vec3(UV, 0.0));
    vec3 tex_dy = _dFdy(vec3(UV, 0.0));
    vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);

#ifdef HAS_NORMALS
    vec3 ng = normalize(v_Normal);
#else
    vec3 ng = cross(pos_dx, pos_dy);
#endif

    t = normalize(t - ng * dot(ng, t));
    vec3 b = normalize(cross(ng, t));
    mat3 tbn = mat3(t, b, ng);
#else // HAS_TANGENTS
    mat3 tbn = v_TBN;
#endif

#ifdef HAS_NORMAL_MAP
    vec3 n = _texture(u_NormalSampler, UV).rgb;
    n = normalize(tbn * ((2.0 * n - 1.0) * vec3(u_NormalScale, u_NormalScale, 1.0)));
#else
    // The tbn matrix is linearly interpolated, so we need to re-normalize
    vec3 n = normalize(tbn[2].xyz);
#endif

    return n;
}

float getPerceivedBrightness(vec3 vector)
{
    return sqrt(0.299 * vector.r * vector.r + 0.587 * vector.g * vector.g + 0.114 * vector.b * vector.b);
}

// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness/examples/convert-between-workflows/js/three.pbrUtilities.js#L34
float solveMetallic(vec3 diffuse, vec3 specular, float oneMinusSpecularStrength) {
    float specularBrightness = getPerceivedBrightness(specular);

    if (specularBrightness < c_MinReflectance) {
        return 0.0;
    }

    float diffuseBrightness = getPerceivedBrightness(diffuse);

    float a = c_MinReflectance;
    float b = diffuseBrightness * oneMinusSpecularStrength / (1.0 - c_MinReflectance) + specularBrightness - 2.0 * c_MinReflectance;
    float c = c_MinReflectance - specularBrightness;
    float D = b * b - 4.0 * a * c;

    return clamp((-b + sqrt(D)) / (2.0 * a), 0.0, 1.0);
}

AngularInfo getAngularInfo(vec3 pointToLight, vec3 normal, vec3 view)
{
    // Standard one-letter names
    vec3 n = normalize(normal);           // Outward direction of surface point
    vec3 v = normalize(view);             // Direction from surface point to view
    vec3 l = normalize(pointToLight);     // Direction from surface point to light
    vec3 h = normalize(l + v);            // Direction of the vector between l and v

    float NdotL = clamp(dot(n, l), 0.0, 1.0);
    float NdotV = clamp(dot(n, v), 0.0, 1.0);
    float NdotH = clamp(dot(n, h), 0.0, 1.0);
    float LdotH = clamp(dot(l, h), 0.0, 1.0);
    float VdotH = clamp(dot(v, h), 0.0, 1.0);

    return AngularInfo(
        NdotL,
        NdotV,
        NdotH,
        LdotH,
        VdotH,
        vec3(0, 0, 0)
    );
}

#ifdef USE_SHADOW_MAPPING
FRAG_IN vec4 v_PositionLightSpace;
#endif

float linstep(float low, float high, float v)
{
    return clamp((v-low) / (high-low), 0.0, 1.0);
}

#ifdef USE_SHADOW_MAPPING
float getShadowContribution()
{
    vec3 coords = v_PositionLightSpace.xyz / v_PositionLightSpace.w * 0.5 + 0.5;
    if (coords.z < 0.01 || coords.z > 0.99 || coords.x < 0.01 || coords.x > 0.99 || coords.y < 0.01 || coords.y > 0.99) {
        return 1.0;
    }
    vec2 moments = vec2(1.0) - _texture(u_ShadowSampler, coords.xy).xy;
    float p = step(coords.z, moments.x);
    float variance = max(moments.y - moments.x * moments.x, 0.00002);
    float d = coords.z - moments.x;
    float pMax = linstep(0.2, 1.0, variance / (variance + d*d));
    return min(max(p, pMax), 1.0);
}
#endif
uniform float u_Exposure;

const float GAMMA = 2.2;
const float INV_GAMMA = 1.0 / GAMMA;

// linear to sRGB approximation
// see http://chilliant.blogspot.com/2012/08/srgb-approximations-for-hlsl.html
vec3 LINEARtoSRGB(vec3 color)
{
    return pow(color, vec3(INV_GAMMA));
}

// sRGB to linear approximation
// see http://chilliant.blogspot.com/2012/08/srgb-approximations-for-hlsl.html
vec4 SRGBtoLINEAR(vec4 srgbIn)
{
    return vec4(pow(srgbIn.xyz, vec3(GAMMA)), srgbIn.w);
}

// Uncharted 2 tone map
// see: http://filmicworlds.com/blog/filmic-tonemapping-operators/
vec3 toneMapUncharted2Impl(vec3 color)
{
    const float A = 0.15;
    const float B = 0.50;
    const float C = 0.10;
    const float D = 0.20;
    const float E = 0.02;
    const float F = 0.30;
    return ((color*(A*color+C*B)+D*E)/(color*(A*color+B)+D*F))-E/F;
}

vec3 toneMapUncharted(vec3 color)
{
    const float W = 11.2;
    color = toneMapUncharted2Impl(color * 2.0);
    vec3 whiteScale = 1.0 / toneMapUncharted2Impl(vec3(W));
    return LINEARtoSRGB(color * whiteScale);
}

// Hejl Richard tone map
// see: http://filmicworlds.com/blog/filmic-tonemapping-operators/
vec3 toneMapHejlRichard(vec3 color)
{
    color = max(vec3(0.0), color - vec3(0.004));
    return (color*(6.2*color+.5))/(color*(6.2*color+1.7)+0.06);
}

// ACES tone map
// see: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/
vec3 toneMapACES(vec3 color)
{
    const float A = 2.51;
    const float B = 0.03;
    const float C = 2.43;
    const float D = 0.59;
    const float E = 0.14;
    return LINEARtoSRGB(clamp((color * (A * color + B)) / (color * (C * color + D) + E), 0.0, 1.0));
}

vec3 toneMap(vec3 color)
{
    color *= u_Exposure;

#ifdef TONEMAP_UNCHARTED
    return toneMapUncharted(color);
#endif

#ifdef TONEMAP_HEJLRICHARD
    return toneMapHejlRichard(color);
#endif

#ifdef TONEMAP_ACES
    return toneMapACES(color);
#endif

    return LINEARtoSRGB(color);
}

vec4 encodeRGBE(vec3 rgb) {
  vec4 vEncoded;
  float maxComponent = max(max(rgb.r, rgb.g), rgb.b);
  float fExp = ceil(log2(maxComponent));
  vEncoded.rgb = rgb / exp2(fExp);
  vEncoded.a = (fExp + 128.0) / 255.0;
  return vEncoded;
}

vec3 decodeRGBE(vec4 rgbe) {
  vec3 vDecoded;
  float fExp = rgbe.a * 255.0 - 128.0;
  vDecoded = rgbe.rgb * exp2(fExp);
  return vDecoded;
}

// KHR_lights_punctual extension.
// see https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual

struct Light
{
    vec3 direction;
    float range;

    vec3 color;
    float intensity;

    vec3 position;
    float innerConeCos;

    float outerConeCos;
    int type;

    vec2 padding;
};

const int LightType_Directional = 0;
const int LightType_Point = 1;
const int LightType_Spot = 2;

#ifdef USE_PUNCTUAL
uniform Light u_Lights[LIGHT_COUNT];
#endif

#ifdef USE_FOG
uniform float u_FogNear;
uniform float u_FogFar;
uniform vec3 u_FogColor;
#endif

#if defined(MATERIAL_SPECULARGLOSSINESS) || defined(MATERIAL_METALLICROUGHNESS)
uniform float u_MetallicFactor;
uniform float u_RoughnessFactor;
uniform vec4 u_BaseColorFactor;
#endif

#ifdef USE_INSTANCING
FRAG_IN vec4 v_BaseColorFactor;
#endif

#ifdef MATERIAL_SPECULARGLOSSINESS
uniform vec3 u_SpecularFactor;
uniform vec4 u_DiffuseFactor;
uniform float u_GlossinessFactor;
#endif

#ifdef ALPHAMODE_MASK
uniform float u_AlphaCutoff;
#endif

#ifdef USE_SHADOW_MAPPING
uniform int u_ShadowLightIndex;
#endif

uniform vec3 u_Camera;

uniform int u_MipCount;

struct MaterialInfo
{
    float perceptualRoughness;    // roughness value, as authored by the model creator (input to shader)
    vec3 reflectance0;            // full reflectance color (normal incidence angle)

    float alphaRoughness;         // roughness mapped to a more linear change in the roughness (proposed by [2])
    vec3 diffuseColor;            // color contribution from diffuse lighting

    vec3 reflectance90;           // reflectance color at grazing angle
    vec3 specularColor;           // color contribution from specular lighting
};

// Calculation of the lighting contribution from an optional Image Based Light source.
// Precomputed Environment Maps are required uniform inputs and are computed as outlined in [1].
// See our README.md on Environment Maps [3] for additional discussion.
#ifdef USE_IBL
vec3 getIBLContribution(MaterialInfo materialInfo, vec3 n, vec3 v)
{
    float NdotV = clamp(dot(n, v), 0.0, 1.0);

    float lod = clamp(materialInfo.perceptualRoughness * float(u_MipCount), 0.0, float(u_MipCount));
    vec3 reflection = normalize(reflect(-v, n));

    vec2 brdfSamplePoint = clamp(vec2(NdotV, materialInfo.perceptualRoughness), vec2(0.0, 0.0), vec2(1.0, 1.0));
    // retrieve a scale and bias to F0. See [1], Figure 3
    vec2 brdf = _texture(u_brdfLUT, brdfSamplePoint).rg;

    vec4 diffuseSample = _texture(u_DiffuseEnvSampler, n);

#ifdef USE_TEX_LOD
    vec4 specularSample = _textureLod(u_SpecularEnvSampler, reflection, lod);
#else
    vec4 specularSample = _texture(u_SpecularEnvSampler, reflection);
#endif

#if defined(USE_HDR)
    // Already linear.
    vec3 diffuseLight = diffuseSample.rgb;
    vec3 specularLight = specularSample.rgb;
#elif defined(USE_RGBE)
    vec3 diffuseLight = decodeRGBE(diffuseSample);
    vec3 specularLight = decodeRGBE(specularSample);
#else
    vec3 diffuseLight = SRGBtoLINEAR(diffuseSample).rgb;
    vec3 specularLight = SRGBtoLINEAR(specularSample).rgb;
#endif

    vec3 diffuse = diffuseLight * materialInfo.diffuseColor;
    vec3 specular = specularLight * (materialInfo.specularColor * brdf.x + brdf.y);

    return diffuse + specular;
}
#endif

// Lambert lighting
// see https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/
vec3 diffuse(MaterialInfo materialInfo)
{
    return materialInfo.diffuseColor / M_PI;
}

// The following equation models the Fresnel reflectance term of the spec equation (aka F())
// Implementation of fresnel from [4], Equation 15
vec3 specularReflection(MaterialInfo materialInfo, AngularInfo angularInfo)
{
    return materialInfo.reflectance0 + (materialInfo.reflectance90 - materialInfo.reflectance0) * pow(clamp(1.0 - angularInfo.VdotH, 0.0, 1.0), 5.0);
}

// Smith Joint GGX
// Note: Vis = G / (4 * NdotL * NdotV)
// see Eric Heitz. 2014. Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs. Journal of Computer Graphics Techniques, 3
// see Real-Time Rendering. Page 331 to 336.
// see https://google.github.io/filament/Filament.md.html#materialsystem/specularbrdf/geometricshadowing(specularg)
float visibilityOcclusion(MaterialInfo materialInfo, AngularInfo angularInfo)
{
    float NdotL = angularInfo.NdotL;
    float NdotV = angularInfo.NdotV;
    float alphaRoughnessSq = materialInfo.alphaRoughness * materialInfo.alphaRoughness;

    float GGXV = NdotL * sqrt(NdotV * NdotV * (1.0 - alphaRoughnessSq) + alphaRoughnessSq);
    float GGXL = NdotV * sqrt(NdotL * NdotL * (1.0 - alphaRoughnessSq) + alphaRoughnessSq);

    float GGX = GGXV + GGXL;
    if (GGX > 0.0)
    {
        return 0.5 / GGX;
    }
    return 0.0;
}

// The following equation(s) model the distribution of microfacet normals across the area being drawn (aka D())
// Implementation from "Average Irregularity Representation of a Roughened Surface for Ray Reflection" by T. S. Trowbridge, and K. P. Reitz
// Follows the distribution function recommended in the SIGGRAPH 2013 course notes from EPIC Games [1], Equation 3.
float microfacetDistribution(MaterialInfo materialInfo, AngularInfo angularInfo)
{
    float alphaRoughnessSq = materialInfo.alphaRoughness * materialInfo.alphaRoughness;
    float f = (angularInfo.NdotH * alphaRoughnessSq - angularInfo.NdotH) * angularInfo.NdotH + 1.0;
    return alphaRoughnessSq / (M_PI * f * f);
}

vec3 getPointShade(vec3 pointToLight, MaterialInfo materialInfo, vec3 normal, vec3 view)
{
    AngularInfo angularInfo = getAngularInfo(pointToLight, normal, view);

    if (angularInfo.NdotL > 0.0 || angularInfo.NdotV > 0.0)
    {
        // Calculate the shading terms for the microfacet specular shading model
        vec3 F = specularReflection(materialInfo, angularInfo);
        float Vis = visibilityOcclusion(materialInfo, angularInfo);
        float D = microfacetDistribution(materialInfo, angularInfo);

        // Calculation of analytical lighting contribution
        vec3 diffuseContrib = (1.0 - F) * diffuse(materialInfo);
        vec3 specContrib = F * Vis * D;

        // Obtain final intensity as reflectance (BRDF) scaled by the energy of the light (cosine law)
        return angularInfo.NdotL * (diffuseContrib + specContrib);
    }

    return vec3(0.0, 0.0, 0.0);
}

// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#range-property
float getRangeAttenuation(float range, float distance)
{
    if (range <= 0.0)
    {
        // negative range means unlimited
        return 1.0;
    }
    return max(min(1.0 - pow(distance / range, 4.0), 1.0), 0.0) / pow(distance, 2.0);
}

// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#inner-and-outer-cone-angles
float getSpotAttenuation(vec3 pointToLight, vec3 spotDirection, float outerConeCos, float innerConeCos)
{
    float actualCos = dot(normalize(spotDirection), normalize(-pointToLight));
    if (actualCos > outerConeCos)
    {
        if (actualCos < innerConeCos)
        {
            return smoothstep(outerConeCos, innerConeCos, actualCos);
        }
        return 1.0;
    }
    return 0.0;
}

vec3 applyDirectionalLight(Light light, MaterialInfo materialInfo, vec3 normal, vec3 view, float shadow)
{
    vec3 pointToLight = -light.direction;
    vec3 shade = getPointShade(pointToLight, materialInfo, normal, view) * shadow;
    return light.intensity * light.color * shade;
}

vec3 applyPointLight(Light light, MaterialInfo materialInfo, vec3 normal, vec3 view)
{
    vec3 pointToLight = light.position - v_Position;
    float distance = length(pointToLight);
    float attenuation = getRangeAttenuation(light.range, distance);
    vec3 shade = getPointShade(pointToLight, materialInfo, normal, view);
    return attenuation * light.intensity * light.color * shade;
}

vec3 applySpotLight(Light light, MaterialInfo materialInfo, vec3 normal, vec3 view, float shadow)
{
    vec3 pointToLight = light.position - v_Position;
    float distance = length(pointToLight);
    float rangeAttenuation = getRangeAttenuation(light.range, distance);
    float spotAttenuation = getSpotAttenuation(pointToLight, light.direction, light.outerConeCos, light.innerConeCos);
    vec3 shade = getPointShade(pointToLight, materialInfo, normal, view) * shadow;
    return rangeAttenuation * spotAttenuation * light.intensity * light.color * shade;
}

#ifdef WEBGL2
    out vec4 FRAG_COLOR;
#endif

void main()
{
    // Metallic and Roughness material properties are packed together
    // In glTF, these factors can be specified by fixed scalar values
    // or from a metallic-roughness map
    float perceptualRoughness = 0.0;
    float metallic = 0.0;
    vec4 baseColor = vec4(0.0, 0.0, 0.0, 1.0);
    vec3 diffuseColor = vec3(0.0);
    vec3 specularColor= vec3(0.0);
    vec3 f0 = vec3(0.04);

#ifdef MATERIAL_SPECULARGLOSSINESS

#ifdef HAS_SPECULAR_GLOSSINESS_MAP
    vec4 sgSample = SRGBtoLINEAR(_texture(u_SpecularGlossinessSampler, getSpecularGlossinessUV()));
    perceptualRoughness = (1.0 - sgSample.a * u_GlossinessFactor); // glossiness to roughness
    f0 = sgSample.rgb * u_SpecularFactor; // specular
#else
    f0 = u_SpecularFactor;
    perceptualRoughness = 1.0 - u_GlossinessFactor;
#endif // ! HAS_SPECULAR_GLOSSINESS_MAP

#ifdef HAS_DIFFUSE_MAP
    baseColor = SRGBtoLINEAR(_texture(u_DiffuseSampler, getDiffuseUV())) * u_DiffuseFactor;
#else
    baseColor = u_DiffuseFactor;
#endif // !HAS_DIFFUSE_MAP

    baseColor *= getVertexColor();

    // f0 = specular
    specularColor = f0;
    float oneMinusSpecularStrength = 1.0 - max(max(f0.r, f0.g), f0.b);
    diffuseColor = baseColor.rgb * oneMinusSpecularStrength;

#ifdef DEBUG_METALLIC
    // do conversion between metallic M-R and S-G metallic
    metallic = solveMetallic(baseColor.rgb, specularColor, oneMinusSpecularStrength);
#endif // ! DEBUG_METALLIC

#endif // ! MATERIAL_SPECULARGLOSSINESS

#ifdef MATERIAL_METALLICROUGHNESS

#ifdef HAS_METALLIC_ROUGHNESS_MAP
    // Roughness is stored in the 'g' channel, metallic is stored in the 'b' channel.
    // This layout intentionally reserves the 'r' channel for (optional) occlusion map data
    vec4 mrSample = _texture(u_MetallicRoughnessSampler, getMetallicRoughnessUV());
    perceptualRoughness = mrSample.g * u_RoughnessFactor;
    metallic = mrSample.b * u_MetallicFactor;
#else
    metallic = u_MetallicFactor;
    perceptualRoughness = u_RoughnessFactor;
#endif

    vec4 baseColorFactor = u_BaseColorFactor;
#ifdef USE_INSTANCING
    baseColorFactor = v_BaseColorFactor;
#endif

    // The albedo may be defined from a base texture or a flat color
#if defined(HAS_BASE_COLOR_MAP) && defined(MATERIAL_UNLIT)
    baseColor = _texture(u_BaseColorSampler, getBaseColorUV()) * baseColorFactor;
#elif defined(HAS_BASE_COLOR_MAP)
    baseColor = SRGBtoLINEAR(_texture(u_BaseColorSampler, getBaseColorUV())) * baseColorFactor;
#else
    baseColor = baseColorFactor;
#endif

    baseColor *= getVertexColor();

    diffuseColor = baseColor.rgb * (vec3(1.0) - f0) * (1.0 - metallic);

    specularColor = mix(f0, baseColor.rgb, metallic);

#endif // ! MATERIAL_METALLICROUGHNESS

#ifdef ALPHAMODE_MASK
    if(baseColor.a < u_AlphaCutoff)
    {
        discard;
    }
    baseColor.a = 1.0;
#endif

#ifdef ALPHAMODE_OPAQUE
    baseColor.a = 1.0;
#endif

#ifdef MATERIAL_UNLIT
    FRAG_COLOR = vec4(baseColor.rgb * baseColor.a, baseColor.a);
    return;
#endif

    perceptualRoughness = clamp(perceptualRoughness, 0.0, 1.0);
    metallic = clamp(metallic, 0.0, 1.0);

    // Roughness is authored as perceptual roughness; as is convention,
    // convert to material roughness by squaring the perceptual roughness [2].
    float alphaRoughness = perceptualRoughness * perceptualRoughness;

    // Compute reflectance.
    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);

    vec3 specularEnvironmentR0 = specularColor.rgb;
    // Anything less than 2% is physically impossible and is instead considered to be shadowing. Compare to "Real-Time-Rendering" 4th editon on page 325.
    vec3 specularEnvironmentR90 = vec3(clamp(reflectance * 50.0, 0.0, 1.0));

    MaterialInfo materialInfo = MaterialInfo(
        perceptualRoughness,
        specularEnvironmentR0,
        alphaRoughness,
        diffuseColor,
        specularEnvironmentR90,
        specularColor
    );

    // LIGHTING

    vec3 color = vec3(0.0, 0.0, 0.0);
    vec3 normal = getNormal();
    vec3 view = normalize(u_Camera - v_Position);

    float shadow = 1.0;
    #ifdef USE_SHADOW_MAPPING
        shadow = getShadowContribution();
    #endif

#ifdef USE_PUNCTUAL
    for (int i = 0; i < LIGHT_COUNT; ++i)
    {
        float shadowContribution = shadow;
        #ifdef USE_SHADOW_MAPPING
        if (u_ShadowLightIndex != i) 
        {
            shadowContribution = 1.0;
        }
        #endif
        Light light = u_Lights[i];
        if (light.type == LightType_Directional)
        {
            color += applyDirectionalLight(light, materialInfo, normal, view, shadowContribution);
        }
        else if (light.type == LightType_Point)
        {
            color += applyPointLight(light, materialInfo, normal, view);
        }
        else if (light.type == LightType_Spot)
        {
            color += applySpotLight(light, materialInfo, normal, view, shadowContribution);
        }
    }
#endif

    // Calculate lighting contribution from image based lighting source (IBL)
#ifdef USE_IBL
    color += getIBLContribution(materialInfo, normal, view);
#endif

    float ao = 1.0;
    // Apply optional PBR terms for additional (optional) shading
#ifdef HAS_OCCLUSION_MAP
    ao = _texture(u_OcclusionSampler,  getOcclusionUV()).r;
    color = mix(color, color * ao, u_OcclusionStrength);
#endif

    vec3 emissive = vec3(0);
#ifdef HAS_EMISSIVE_MAP
    emissive = SRGBtoLINEAR(_texture(u_EmissiveSampler, getEmissiveUV())).rgb * u_EmissiveFactor;
    color += emissive;
#endif

#ifndef DEBUG_OUTPUT // no debug

    vec3 toneMappedColor = toneMap(color);

    #ifdef USE_FOG
        float fogDepth = -v_ModelViewPosition.z;
        float fogFactor = smoothstep(u_FogNear, u_FogFar, fogDepth);
        toneMappedColor = mix(toneMappedColor, u_FogColor, fogFactor);
    #endif

    // regular shading
    FRAG_COLOR = vec4(toneMappedColor * baseColor.a, baseColor.a);

#else // debug output

    #ifdef DEBUG_METALLIC
        FRAG_COLOR.rgb = vec3(metallic);
    #endif

    #ifdef DEBUG_ROUGHNESS
        FRAG_COLOR.rgb = vec3(perceptualRoughness);
    #endif

    #ifdef DEBUG_NORMAL
        #ifdef HAS_NORMAL_MAP
            FRAG_COLOR.rgb = _texture(u_NormalSampler, getNormalUV()).rgb;
        #else
            FRAG_COLOR.rgb = vec3(0.5, 0.5, 1.0);
        #endif
    #endif

    #ifdef DEBUG_BASECOLOR
        FRAG_COLOR.rgb = LINEARtoSRGB(baseColor.rgb);
    #endif

    #ifdef DEBUG_OCCLUSION
        FRAG_COLOR.rgb = vec3(ao);
    #endif

    #ifdef DEBUG_EMISSIVE
        FRAG_COLOR.rgb = LINEARtoSRGB(emissive);
    #endif

    #ifdef DEBUG_F0
        FRAG_COLOR.rgb = vec3(f0);
    #endif

    #ifdef DEBUG_ALPHA
        FRAG_COLOR.rgb = vec3(baseColor.a);
    #endif

    FRAG_COLOR.a = 1.0;

#endif // !DEBUG_OUTPUT
}
`},Sn={source:`#version VERSION

#define FEATURES

vec4 _texture(sampler2D sampler, vec2 coord)
{
#ifdef WEBGL2
    return texture(sampler, coord);
#else
    return texture2D(sampler, coord);
#endif
}

vec4 _texture(samplerCube sampler, vec3 coord)
{
#ifdef WEBGL2
    return texture(sampler, coord);
#else
    return textureCube(sampler, coord);
#endif
}
#ifdef HAS_TARGET_POSITION0
VERT_IN vec3 a_Target_Position0;
#endif

#ifdef HAS_TARGET_POSITION1
VERT_IN vec3 a_Target_Position1;
#endif

#ifdef HAS_TARGET_POSITION2
VERT_IN vec3 a_Target_Position2;
#endif

#ifdef HAS_TARGET_POSITION3
VERT_IN vec3 a_Target_Position3;
#endif

#ifdef HAS_TARGET_POSITION4
VERT_IN vec3 a_Target_Position4;
#endif

#ifdef HAS_TARGET_POSITION5
VERT_IN vec3 a_Target_Position5;
#endif

#ifdef HAS_TARGET_POSITION6
VERT_IN vec3 a_Target_Position6;
#endif

#ifdef HAS_TARGET_POSITION7
VERT_IN vec3 a_Target_Position7;
#endif

#ifdef HAS_TARGET_NORMAL0
VERT_IN vec3 a_Target_Normal0;
#endif

#ifdef HAS_TARGET_NORMAL1
VERT_IN vec3 a_Target_Normal1;
#endif

#ifdef HAS_TARGET_NORMAL2
VERT_IN vec3 a_Target_Normal2;
#endif

#ifdef HAS_TARGET_NORMAL3
VERT_IN vec3 a_Target_Normal3;
#endif

#ifdef HAS_TARGET_TANGENT0
VERT_IN vec3 a_Target_Tangent0;
#endif

#ifdef HAS_TARGET_TANGENT1
VERT_IN vec3 a_Target_Tangent1;
#endif

#ifdef HAS_TARGET_TANGENT2
VERT_IN vec3 a_Target_Tangent2;
#endif

#ifdef HAS_TARGET_TANGENT3
VERT_IN vec3 a_Target_Tangent3;
#endif

#ifdef USE_MORPHING
uniform float u_morphWeights[WEIGHT_COUNT];
#endif

#ifdef HAS_JOINT_SET1
VERT_IN vec4 a_Joint1;
#endif

#ifdef HAS_JOINT_SET2
VERT_IN vec4 a_Joint2;
#endif

#ifdef HAS_WEIGHT_SET1
VERT_IN vec4 a_Weight1;
#endif

#ifdef HAS_WEIGHT_SET2
VERT_IN vec4 a_Weight2;
#endif

#ifdef USE_SKINNING
#ifdef USE_SKINNING_TEXTURE
uniform sampler2D u_jointMatrixSampler;
uniform sampler2D u_jointNormalMatrixSampler;
#else
uniform mat4 u_jointMatrix[JOINT_COUNT];
uniform mat4 u_jointNormalMatrix[JOINT_COUNT];
#endif
#endif

// these offsets assume the texture is 4 pixels across
#define ROW0_U ((0.5 + 0.0) / 4.0)
#define ROW1_U ((0.5 + 1.0) / 4.0)
#define ROW2_U ((0.5 + 2.0) / 4.0)
#define ROW3_U ((0.5 + 3.0) / 4.0)

#ifdef USE_SKINNING
mat4 getJointMatrix(float boneNdx) {
    #ifdef USE_SKINNING_TEXTURE
    float v = (boneNdx + 0.5) / float(JOINT_COUNT);
    return mat4(
        _texture(u_jointMatrixSampler, vec2(ROW0_U, v)),
        _texture(u_jointMatrixSampler, vec2(ROW1_U, v)),
        _texture(u_jointMatrixSampler, vec2(ROW2_U, v)),
        _texture(u_jointMatrixSampler, vec2(ROW3_U, v))
    );
    #else
    return u_jointMatrix[int(boneNdx)];
    #endif
}

mat4 getJointNormalMatrix(float boneNdx) {
    #ifdef USE_SKINNING_TEXTURE
    float v = (boneNdx + 0.5) / float(JOINT_COUNT);
    return mat4(
        _texture(u_jointNormalMatrixSampler, vec2(ROW0_U, v)),
        _texture(u_jointNormalMatrixSampler, vec2(ROW1_U, v)),
        _texture(u_jointNormalMatrixSampler, vec2(ROW2_U, v)),
        _texture(u_jointNormalMatrixSampler, vec2(ROW3_U, v))
    );
    #else
    return u_jointNormalMatrix[int(boneNdx)];
    #endif
}

mat4 getSkinningMatrix()
{
    mat4 skin = mat4(0);

    #if defined(HAS_WEIGHT_SET1) && defined(HAS_JOINT_SET1)
    skin +=
        a_Weight1.x * getJointMatrix(a_Joint1.x) +
        a_Weight1.y * getJointMatrix(a_Joint1.y) +
        a_Weight1.z * getJointMatrix(a_Joint1.z) +
        a_Weight1.w * getJointMatrix(a_Joint1.w);
    #endif

    return skin;
}

mat4 getSkinningNormalMatrix()
{
    mat4 skin = mat4(0);

    #if defined(HAS_WEIGHT_SET1) && defined(HAS_JOINT_SET1)
    skin +=
        a_Weight1.x * getJointNormalMatrix(a_Joint1.x) +
        a_Weight1.y * getJointNormalMatrix(a_Joint1.y) +
        a_Weight1.z * getJointNormalMatrix(a_Joint1.z) +
        a_Weight1.w * getJointNormalMatrix(a_Joint1.w);
    #endif

    return skin;
}
#endif // !USE_SKINNING

#ifdef USE_MORPHING
vec4 getTargetPosition()
{
    vec4 pos = vec4(0);

#ifdef HAS_TARGET_POSITION0
    pos.xyz += u_morphWeights[0] * a_Target_Position0;
#endif

#ifdef HAS_TARGET_POSITION1
    pos.xyz += u_morphWeights[1] * a_Target_Position1;
#endif

#ifdef HAS_TARGET_POSITION2
    pos.xyz += u_morphWeights[2] * a_Target_Position2;
#endif

#ifdef HAS_TARGET_POSITION3
    pos.xyz += u_morphWeights[3] * a_Target_Position3;
#endif

#ifdef HAS_TARGET_POSITION4
    pos.xyz += u_morphWeights[4] * a_Target_Position4;
#endif

    return pos;
}

vec4 getTargetNormal()
{
    vec4 normal = vec4(0);

#ifdef HAS_TARGET_NORMAL0
    normal.xyz += u_morphWeights[0] * a_Target_Normal0;
#endif

#ifdef HAS_TARGET_NORMAL1
    normal.xyz += u_morphWeights[1] * a_Target_Normal1;
#endif

#ifdef HAS_TARGET_NORMAL2
    normal.xyz += u_morphWeights[2] * a_Target_Normal2;
#endif

#ifdef HAS_TARGET_NORMAL3
    normal.xyz += u_morphWeights[3] * a_Target_Normal3;
#endif

#ifdef HAS_TARGET_NORMAL4
    normal.xyz += u_morphWeights[4] * a_Target_Normal4;
#endif

    return normal;
}

vec4 getTargetTangent()
{
    vec4 tangent = vec4(0);

#ifdef HAS_TARGET_TANGENT0
    tangent.xyz += u_morphWeights[0] * a_Target_Tangent0;
#endif

#ifdef HAS_TARGET_TANGENT1
    tangent.xyz += u_morphWeights[1] * a_Target_Tangent1;
#endif

#ifdef HAS_TARGET_TANGENT2
    tangent.xyz += u_morphWeights[2] * a_Target_Tangent2;
#endif

#ifdef HAS_TARGET_TANGENT3
    tangent.xyz += u_morphWeights[3] * a_Target_Tangent3;
#endif

#ifdef HAS_TARGET_TANGENT4
    tangent.xyz += u_morphWeights[4] * a_Target_Tangent4;
#endif

    return tangent;
}

#endif // !USE_MORPHING


VERT_IN vec4 a_Position;
VERT_OUT vec3 v_Position;

VERT_OUT vec3 v_ModelViewPosition;

#ifdef USE_INSTANCING
VERT_IN vec4 a_ModelMatrix0;
VERT_IN vec4 a_ModelMatrix1;
VERT_IN vec4 a_ModelMatrix2;
VERT_IN vec4 a_ModelMatrix3;
#endif

#ifdef USE_INSTANCING
VERT_IN vec4 a_BaseColorFactor;
VERT_OUT vec4 v_BaseColorFactor;
#endif

#ifdef USE_INSTANCING
VERT_IN vec4 a_NormalMatrix0;
VERT_IN vec4 a_NormalMatrix1;
VERT_IN vec4 a_NormalMatrix2;
VERT_IN vec4 a_NormalMatrix3;
#endif

#ifdef HAS_NORMALS
VERT_IN vec4 a_Normal;
#endif

#ifdef HAS_TANGENTS
VERT_IN vec4 a_Tangent;
#endif

#ifdef HAS_NORMALS
#ifdef HAS_TANGENTS
VERT_OUT mat3 v_TBN;
#else
VERT_OUT vec3 v_Normal;
#endif
#endif

#ifdef HAS_UV_SET1
VERT_IN vec2 a_UV1;
#endif

#ifdef HAS_UV_SET2
VERT_IN vec2 a_UV2;
#endif

VERT_OUT vec2 v_UVCoord1;
VERT_OUT vec2 v_UVCoord2;

#ifdef HAS_VERTEX_COLOR_VEC3
VERT_IN vec3 a_Color;
VERT_OUT vec3 v_Color;
#endif

#ifdef HAS_VERTEX_COLOR_VEC4
VERT_IN vec4 a_Color;
VERT_OUT vec4 v_Color;
#endif

uniform mat4 u_ViewProjectionMatrix;
uniform mat4 u_ModelMatrix;
uniform mat4 u_ViewMatrix;
uniform mat4 u_NormalMatrix;

#ifdef USE_SHADOW_MAPPING
uniform mat4 u_LightViewProjectionMatrix;
VERT_OUT vec4 v_PositionLightSpace;
#endif

vec4 getPosition()
{
    vec4 pos = a_Position;

#ifdef USE_MORPHING
    pos += getTargetPosition();
#endif

#ifdef USE_SKINNING
    pos = getSkinningMatrix() * pos;
#endif

    return pos;
}

#ifdef HAS_NORMALS
vec4 getNormal()
{
    vec4 normal = a_Normal;

#ifdef USE_MORPHING
    normal += getTargetNormal();
#endif

#ifdef USE_SKINNING
    normal = getSkinningNormalMatrix() * normal;
#endif

    return normalize(normal);
}
#endif

#ifdef HAS_TANGENTS
vec4 getTangent()
{
    vec4 tangent = a_Tangent;

#ifdef USE_MORPHING
    tangent += getTargetTangent();
#endif

#ifdef USE_SKINNING
    tangent = getSkinningMatrix() * tangent;
#endif

    return normalize(tangent);
}
#endif

void main()
{
    mat4 modelMatrix = u_ModelMatrix;
    #ifdef USE_INSTANCING
        modelMatrix = mat4(a_ModelMatrix0, a_ModelMatrix1, a_ModelMatrix2, a_ModelMatrix3);
    #endif
    vec4 pos = modelMatrix * getPosition();
    v_Position = vec3(pos.xyz) / pos.w;

    vec4 modelViewPosition = u_ViewMatrix * pos;
    v_ModelViewPosition = vec3(modelViewPosition.xyz) / modelViewPosition.w;

    mat4 normalMatrix = u_NormalMatrix;
    #ifdef USE_INSTANCING
        normalMatrix = mat4(a_NormalMatrix0, a_NormalMatrix1, a_NormalMatrix2, a_NormalMatrix3);
    #endif

    #ifdef HAS_NORMALS
    #ifdef HAS_TANGENTS
    vec4 tangent = getTangent();
    vec3 normalW = normalize(vec3(normalMatrix * vec4(getNormal().xyz, 0.0)));
    vec3 tangentW = normalize(vec3(modelMatrix * vec4(tangent.xyz, 0.0)));
    vec3 bitangentW = cross(normalW, tangentW) * tangent.w;
    v_TBN = mat3(tangentW, bitangentW, normalW);
    #else // !HAS_TANGENTS
    v_Normal = normalize(vec3(normalMatrix * vec4(getNormal().xyz, 0.0)));
    #endif
    #endif // !HAS_NORMALS

    v_UVCoord1 = vec2(0.0, 0.0);
    v_UVCoord2 = vec2(0.0, 0.0);

    #ifdef HAS_UV_SET1
    v_UVCoord1 = a_UV1;
    #endif

    #ifdef HAS_UV_SET2
    v_UVCoord2 = a_UV2;
    #endif

    #if defined(HAS_VERTEX_COLOR_VEC3) || defined(HAS_VERTEX_COLOR_VEC4)
    v_Color = a_Color;
    #endif

    #ifdef USE_SHADOW_MAPPING
    v_PositionLightSpace = u_LightViewProjectionMatrix * pos;
    #endif

    #ifdef USE_INSTANCING
    v_BaseColorFactor = a_BaseColorFactor;
    #endif

    gl_Position = u_ViewProjectionMatrix * pos;
}
`};class nt extends Ae{constructor(){super(...arguments),this._instancing=new xn}static build(e,t){let n=p.Program.from(de.build(Sn.source,t,e),de.build(wn.source,t,e));return new nt(n)}get name(){return"standard-shader"}createShaderGeometry(e,t){let n=super.createShaderGeometry(e,t);if(t&&this._instancing.addGeometryAttributes(n),e.targets)for(let i=0;i<e.targets.length;i++){let a=e.targets[i].positions;a&&n.addAttribute(`a_Target_Position${i}`,new p.Buffer(a.buffer),3,a.normalized,a.componentType,a.stride);let s=e.targets[i].normals;s&&n.addAttribute(`a_Target_Normal${i}`,new p.Buffer(s.buffer),3,s.normalized,s.componentType,s.stride);let o=e.targets[i].tangents;o&&n.addAttribute(`a_Target_Tangent${i}`,new p.Buffer(o.buffer),3,o.normalized,o.componentType,o.stride)}return e.uvs&&e.uvs[1]&&n.addAttribute("a_UV2",new p.Buffer(e.uvs[1].buffer),2,e.uvs[1].normalized,e.uvs[1].componentType,e.uvs[1].stride),e.joints&&n.addAttribute("a_Joint1",new p.Buffer(e.joints.buffer),4,e.joints.normalized,e.joints.componentType,e.joints.stride),e.weights&&n.addAttribute("a_Weight1",new p.Buffer(e.weights.buffer),4,e.weights.normalized,e.weights.componentType,e.weights.stride),n}render(e,t,n,i){if(e.instances.length>0){const a=e.instances.filter(s=>s.worldVisible&&s.renderable);if(a.length===0)return;this._instancing.updateBuffers(a)}super.render(e,t,n,i)}}var ye=(r=>(r.opaque="opaque",r.transparent="transparent",r))(ye||{});class Ce{constructor(){this._renderSortType=ye.opaque,this.state=Object.assign(new p.State,{culling:!0,clockwiseFrontFace:!1,depthTest:!0}),this.drawMode=C.DRAW_MODES.TRIANGLES,this.renderSortType=ye.opaque}get depthMask(){return this.state.depthMask}set depthMask(e){this.state.depthMask=e}get doubleSided(){return!this.state.culling}set doubleSided(e){this.state.culling=!e}get blendMode(){return this.state.blendMode}set blendMode(e){this.state.blendMode=e}createShader(e,t){}updateUniforms(e,t){}destroy(){}get isInstancingSupported(){return!1}createInstance(){}render(e,t){!this._shader&&(this._shader=this.createShader(e,t),!this._shader)||(this.updateUniforms&&this.updateUniforms(e,this._shader),this._shader.render(e,t,this.state,this.drawMode))}static from(e,t,n){return Object.assign(new Ce,{updateUniforms:n||(()=>{}),_shader:new Ae(p.Program.from(e,t))})}}class fe{constructor(e,t){this.renderer=e,this.lights=[],this.renderer.on("prerender",()=>{for(let n of this.lights)n.parent||n.transform.updateTransform()}),fe.main||(fe.main=this),this.imageBasedLighting=t}destroy(){}get valid(){return!this.imageBasedLighting||this.imageBasedLighting.valid}}N.installRendererPlugin("lighting",fe);class yn{enableJointMatrixTextures(e){this._jointMatrixTexture||(this._jointMatrixTexture=new we(e)),this._jointNormalTexture||(this._jointNormalTexture=new we(e))}destroy(){var e,t;(e=this._jointNormalTexture)==null||e.destroy(!0),(t=this._jointMatrixTexture)==null||t.destroy(!0)}update(e,t){!e.skin||(this._jointMatrixTexture?(this._jointMatrixTexture.updateBuffer(e.skin.jointMatrices),t.uniforms.u_jointMatrixSampler=this._jointMatrixTexture):t.uniforms.u_jointMatrix=e.skin.jointMatrices,this._jointNormalTexture?(this._jointNormalTexture.updateBuffer(e.skin.jointNormalMatrices),t.uniforms.u_jointNormalMatrixSampler=this._jointNormalTexture):t.uniforms.u_jointNormalMatrix=e.skin.jointNormalMatrices)}}class K{constructor(e=0,t=0,n=0,i=1){this._array4=new Float32Array([e,t,n,i]),this._array3=this._array4.subarray(0,3)}static fromBytes(e=0,t=0,n=0,i=255){return new K(e/255,t/255,n/255,i/255)}static fromHex(e){return typeof e=="string"&&(e=parseInt(e.replace(/[^0-9A-F]/gi,""),16)),K.fromBytes(e>>16&255,e>>8&255,e&255)}get rgb(){return this._array3}get rgba(){return this._array4}get r(){return this._array4[0]}set r(e){this._array4[0]=e}get g(){return this._array4[1]}set g(e){this._array4[1]=e}get b(){return this._array4[2]}set b(e){this._array4[2]=e}get a(){return this._array4[3]}set a(e){this._array4[3]=e}static from(e){return new K(...e)}}class Dt{constructor(e){this.baseColor=new K(...e.baseColor.rgba)}}class Bt{constructor(){this.alphaCutoff=.5,this.alphaMode="OPAQUE",this.doubleSided=!1,this.roughness=1,this.metallic=1,this.emissiveFactor=[0,0,0],this.baseColor=[1,1,1,1],this.unlit=!1}}class Gt{static multiply(e,t,n=new Float32Array(9)){return pr(n,e,t)}}class he{constructor(){this._rotation=0,this._array=new Float32Array(9),this._dirty=!0,this._translation=new Float32Array([1,0,0,0,1,0,0,0,1]),this._scaling=new Float32Array([1,0,0,0,1,0,0,0,1]),this._rotate=new Float32Array([Math.cos(0),-Math.sin(0),0,Math.sin(0),Math.cos(0),0,0,0,1]),this.offset=new H.ObservablePoint(()=>{this._translation.set([1,0,0,0,1,0,this.offset.x,this.offset.y,1]),this._dirty=!0},void 0),this.scale=new H.ObservablePoint(()=>{this._scaling.set([this.scale.x,0,0,0,this.scale.y,0,0,0,1]),this._dirty=!0},void 0,1,1)}get rotation(){return this._rotation}set rotation(e){this._rotation=e,this._rotate.set([Math.cos(e),-Math.sin(e),0,Math.sin(e),Math.cos(e),0,0,0,1]),this._dirty=!0}get array(){return this._dirty&&(Gt.multiply(Gt.multiply(this._translation,this._rotate,this._array),this._scaling,this._array),this._dirty=!1),this._array}static fromTexture(e){const t=new he;if(!e.frame||e.noFrame)return t;let{x:n,y:i,width:a,height:s}=e.frame;return e.rotate===0&&(t.offset.set(n/e.baseTexture.width,i/e.baseTexture.height),t.scale.set(a/e.baseTexture.width,s/e.baseTexture.height)),e.rotate===2&&(n=e.frame.x+e.frame.width,t.offset.set(n/e.baseTexture.width,i/e.baseTexture.height),t.scale.set(s/e.baseTexture.height,a/e.baseTexture.width),t.rotation=-90*H.DEG_TO_RAD),t}}class Ee extends p.Texture{constructor(e,t){super(e),this.uvSet=t}}class Vt extends Ee{constructor(e,t,n){super(e,n),this.scale=t,this.uvSet=n}}class Ht extends Ee{constructor(e,t,n){super(e,n),this.strength=t,this.uvSet=n}}class zt{create(e){let t=new ie;if(!(e instanceof Bt))return t;switch(t.baseColor=K.from(e.baseColor),e.baseColorTexture&&(t.baseColorTexture=new Ee(e.baseColorTexture.baseTexture,e.baseColorTexture.texCoord),t.baseColorTexture.transform=this.createTextureTransform(e.baseColorTexture)),t.metallic=e.metallic,t.roughness=e.roughness,e.metallicRoughnessTexture&&(t.metallicRoughnessTexture=new Ee(e.metallicRoughnessTexture.baseTexture,e.metallicRoughnessTexture.texCoord),t.metallicRoughnessTexture.transform=this.createTextureTransform(e.metallicRoughnessTexture)),t.emissive=K.from(e.emissiveFactor),e.emissiveTexture&&(t.emissiveTexture=new Ee(e.emissiveTexture.baseTexture,e.emissiveTexture.texCoord),t.emissiveTexture.transform=this.createTextureTransform(e.emissiveTexture)),e.alphaMode){case"BLEND":{t.alphaMode=oe.blend,t.renderSortType=ye.transparent;break}case"MASK":{t.alphaMode=oe.mask;break}case"OPAQUE":{t.alphaMode=oe.blend;break}}return t.unlit=e.unlit,t.doubleSided=e.doubleSided,t.alphaCutoff=e.alphaCutoff,e.normalTexture&&(t.normalTexture=new Vt(e.normalTexture.baseTexture,e.normalTexture.scale,e.normalTexture.texCoord),t.normalTexture.transform=this.createTextureTransform(e.normalTexture)),e.occlusionTexture&&(t.occlusionTexture=new Ht(e.occlusionTexture.baseTexture,e.occlusionTexture.strength,e.occlusionTexture.texCoord),t.occlusionTexture.transform=this.createTextureTransform(e.occlusionTexture)),t}createTextureTransform(e){if(e.transform){const t=new he;return e.transform.offset&&(t.offset.x=e.transform.offset[0],t.offset.y=e.transform.offset[1]),e.transform.rotation!==void 0&&(t.rotation=e.transform.rotation),e.transform.scale&&(t.scale.x=e.transform.scale[0],t.scale.y=e.transform.scale[1]),t}}}var En="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAMAAAD04JH5AAADAFBMVEX/AACvAwC4BgC1BQD7AAD3AQDzAQD+AAD9AAD8AQDpAQC/CACxAwD5BgDACwCtAwDxAQC9CADDEQCrAwC7BwC4AQDfAQB+AADvAQD1AQD7AwB7AABrAADHAQDCDgDiAQCyBQCRAQD5AAC1AQDYAQDNAQCpAQCUAQCeAQB0AABhAAD3BwCnAQDCBwCMAACOAAD6BABvAADFAgDsAQD4AACIAADEDADKAQDnAQCfAQCoAwDuEADqFACAAACFAACKAADzCwCCAAC/AQCbAgDKDQDwDgC9AQDBAgCiAAC7AQCkAADlAQD0CACzAQDjGwBoAADEFgB4AAD2CADGEQDGDADQAQDbAQDGCADSAQDNCwDWAQDdAQDUAQBlAAB2AADJCADBGgCVAgDOEADtAQBxAADSDADBFgCZAADnGADXDADcIgDKEgDDAQBcAADQLQCkAwDSEADPCADfHgClAgDXBwDTCADkDACYAAC9IACxLgCiAwCZAgDIFgDINgDdDADxCgDuCACSAQDnEADqCgCPAQBYAAC+HADYJgDLMACWAADOFgDbEQCtMwDSGwCGAADLBgC4JwDbGADaDADBIACoVQDRIQCgAgCxTQDHGwDVKQC6IwDCPACRbADGIQDMGwBUAADgEQDgBwDXEgDkFQDkBgCHdgDnCQDSFQC1KgDWFwDgFwDgDACaRwDCJwCcAADLKAC4LwC2RwDELwCYZADLIACkPQDcBgC9KACFXgDrEAB/ZQCoOgDGKAC+LgDYHACpTwC6QwCWTQB5bQCiWwCcAgCfQgBxdACMVgCzNAB9fwCeYADXIQC4NwC+NgCxOgCHbQCRUQDDNwCrOQDRJwCnRQCYWQCuQQBnfQC+QACNZABziwBskAAY4QCXAgB4hQBghgBllwC1QACtSACfTgBfngCPXABYpQChSAC7PAB/dwCeVABTkQBKnABRrABBuwA4wwBcjgBKtAByfAAxywBApQA3sAAo1QBshgAK8QAY0QBXmgAkxgBPpAAqugBFrgA1uwB98tmWAAAOvklEQVR4nO3Ye1jW5RnA8d+Wtmmews2yJTlXrVWUmUNLt5xSVrpygqJZQShMwqWYOHSWhvMwkSESRRaej5hT8ZiJpCvDI5annGYecmpaOWdhHnff93O6n+f3exFc17yubTfG1V9+P8/9/F54X73Tp/fs+fqfX37xj8///um+3X/bu27GjDfeWLT+ry+//OqrC9/56PXXX3hh9HPPvTZq1LPP9u//2GO9e7du3bpVq1YPPtimTZuOHTvfAVO7dtOmN9xwQ40aNb6P8z01XqXm/4DTp09//b+9gT2n91zZDezZc6U3sOcKb+CbKw745hvo/7cALkcAgLNwA198fsUAZ8+epUfg8081YNF/EnD2/NmzX14UN3AZG+j8LQDOn7948YsLdAO7964jwHof4DUOeKuSgEoJCPDVhQvn5CPgXsEHLqD3twy4eP4rGAM4OqNMAEqqBGgaCKiM4KLsnzvz7wIucwUIOHXqFAD2nagS4EEGCHkHlSBcwPypc8fPnDmxu7xcAtZXFtAxEFClS7iA/ePHj585se+T8r0nsY+vQgQsrAqA/zC2VnApwgXKHz9z7MSJ8vKT66oM6GwDggQVE85h/tgx6H+iALvoVVgJQBsNqOAOLiUAwLHj1P+k/OTJo0fLynYtWrQdAQeCAI+FBFyu4MyZYzjQ37lTAbYDoAQ28M47RwAw2g94CwFD1UMQBHAFoQ0EOCH7a9dAf9eu7ds/gwUcsAGjLEArDehMAHEHFQpCIPadwDr2d0IfF4B9Adh/5MgmDdggANM4IPAOKhIEMPbp/tq1a9esWbFr1yEEHATA/v1HPpKArQLQXwBaM4C6g6oILM1umRf9MgUoEYAjHPCsAfCHwFqBJagMwSsvL9+p+2tWLN91CAEHAbBDAIoAsHXraxsUYFqGfQfOCmzBpQme6K8V+1+xAvqH8AYObyPAJgLMl4DC/oUIyNCAoXwFwYJLGby9J+HhXyvPv2L58kOHtsACDpZs2wGAjQgoQsDWDRtWwQYKC6dN660BQ4cGrUAIOKEihLdO9CmP/fcPbVl9EBagAEVFRfMBkEeAQgRMQwAKhqKAraBJU74DhxBK4a07KvKiv/z997cA4DABNm+0AatyJECuYJgEKEETJahWrUYIQ8DviaNH1xwVedO3ASsJkAeA/oV0BxkZGbiCYQgY2rGjuITqtWs3byIJ1aoZQqCBabwZKi/6CFgt+wgoFhvII0COWIEGGAEAqtdurgRNqlmEChFeWVkZy8u+BhQX0wbmWwApGNbKABre0bB69eYkAEITIbAMoRQIKMO6Of+bb7733ra3P9y8uXTjgmIQrFzpBwzPGP7WMLaChjDVDQG/BRkCJN4b8MtH1k1/yRIDmAeAxQDIQgAIJtMGADA8tEBMtWqhERri7cI5dEjkZf+9JW8DoLR0AQDm+QCTBQBGCOoRoaEhMINBhHJ4i/Bnn8xTXy6AAxYbQM5kAAy0BTBXw4Qg2Agfw4O3PyDYIvK6//aHY0s5YPHEvKw5c1YJwOSBAwcKAAmuB0A9LQgkuAhG8dZvhxF1kRcLGDsW+wuWLQNAAQDysrJAAIBMIcjImKkFQ68fWq/j1RaBDC4iEEKA1dtlXpyfFjB2EADGIaAAARMJMDUnM1OtYOZMtoJ6MA4hpMF2eJ/hrD64+k19fNEfO2jQbAUAwcSJCJgzNVMLZhoBGhwCM4RU0CDgIIy/X0p9CZgoATlCMHeuLbgepp5LEAaFCKXwXj5Ygj/7Dx+WeeiPpfMPmj2bALkCkJU1a9asOVMVgAvu9RG0QSK0ws/wSkpKDsu+yBNA9MdNWJaeC4D8fNjAmFlZCEDBi3O1gAj39uw5rKcmuAaFMAoOAcDhkm0wS7aZvOqPW5aePk8DxsAKJEAKpmsBEHoSga+BIwzDcjRv7h04cIDnqY8PIC1gQjpuIB8BYyyAEExHQc2ZNYfXvNclaIOFYAwlQcCBHdu2URx+/snzE2CCAOQCYIjcQD8QjM8cLwXTpxNhZs2aKDAEaTAIR8Eh3sIDO2g+xBlr+uNEHwDxCBgyhlbQDwTJ48cLwZQpStByuCHYBoYIYMB4C/djfbPKD1LHFxcAgHgBSEFAPwAkJyvBlCmS0KFlSyS4Bo2wFI7D2w+zGWdsqdtHwMj43PhO0EdAQgIA+iVrwZQpFqGmJAiDD+EyJEQD4HdPqcrLPgBGjoyPj+/UCQEpCQkkSHQE02k6KEKAwVK4DO/Ikf0bN5ZSvlTl9QNAfQB0QoAUJCrB0qVLzQ46dCACM0iEUVgMDQHARhwSLJhtHV8vQAJIkJjIBZJwUwiDQjCF65CABTSiLvoT0kdCHwBJkDeAxEQlGCAE0nCTFDCDi7AZyuFtwllAgtnjFjh57Cc5G0BDWlryABwh6IEAmg7GIBFKwRi2w/sA+8ViAzovnj8EJBEgOjoaAVHqDkCQNmDAeC3o0aBBkEEhtIIzeirAB5uKN8Gb3+JlOLpu+hKAhKjuOImpBEgbwJeAhgYNLINEaIVhcAcAioqpD4IJSEhPF4+f6gMgDPPRKVFRJEhNlQJJ6Np1aVcUEEEaNEIpDIM5UOLBR6+i4iK5gGWyrvpiA2FhtIGoaFcgAANuvrkrInr0sPbAEEEM5fBeQME8GpkXdXX+pKQwBaDpLgmpaS4Bpoe7CEuhGRzijSZA0Tx46wNf6bmqD6cfqfpCEBMVowipqZrw5JNCoAwMYRQWgzlaImD0ShzcQK6Yker1Z/oIiIkhQTYTkOFJmCeeGPDEzS7Cp3AcAuKNnj9aAApyhSCeJkn35QoiY3DioqLi4rKzu2cLQrfULt26pXUTBhhmsBUWw3J48Nl7PgDgnWeBvy/rYeFhkTAkoMmmIUOXLmDoRgaDcBWKYTsI4j1HggI58fG5/PyqHx4eKQWxcUEEMrgIo1AM7WAQbyv0F8+nem5BfH7g+RUgMiYWhgGyb7lFAAIQUsEY2mEgDQAAAvjotbgA3/zmF+R3gt9++vxJ4bB904+MlWMbYCyEUIRkMAhIALB1MU1BPgri8/F3j9p+nSTR9wli+UU4CEshGcphQ1Di4T+ACUE+Tic58vEPNxPpGgSiRYsW2dktblHTJZihHBqiJd7WPCGYKABKIG6/TlIditP3iIjICJjY2AgJaNSoURz810JNgEIytENDtMTLy8P+RBx895vP+2EyXocmIjxCT7NmzWLhT2xss0Y0LfwKy6Egfok3Ko+GBPDecwjrh1t9EKiJlQY9jVwGdwRCtMTbkLdB5qkP7770+cOsvEWQ06dPAIM7QkI0xduwAf/1JcsIojtFq3yS069zjRxot2/fnr6179PHZgQ6LIhFAQDk87LGjNEAGHMBTllPe3f6WJBG1rSowOKtWoWCiVn42S8lRfSjzQOg+9daQ4i2OMESzWlUEaWFAKzCKxCAISkKEM4X4NTlPKSmbVsfpY89AVtRGASskn3YgALwPo/+gM0j1z7ykG/asgm09HHuCAFz5mTNmiUBKSkuILgO/aCpqqZPMy8HAXMMgG2g6v2KOG2DOV5OjgCAIIEAQAiL9PV1+Lt8fhhiqgACQI4AzEpIUBuAXzl2P6BdUb/SJHB4hQYgriAK+5G8789fJeYnlZlLoDiANhAVHRPQ97Vxfl3ZqciFgBwCwOfOlAT4+BWjAeb4/vhVVzWmv7tx48Y8VUtO5WUEmDp1zqx++MlX98PVj5+gfGM1svadKkwtNmTwCguhP3Vqv34JQIhiC3D6dtzXrRtybEBd+aUHATkCADcAnz8V4Bp1Ab48a/NQ/VBzq/1Vt775ql+/LgIy3Q3wBZi8rNttq1T1qX8rADIlICGKAGwBvM/PbrXZX3e/nDsrnkfpjxxvWmFmjtpAlAbQr1+nz+tW3G0+b+bRS443bbLeALsBp6/zfOsmjak7Te/hwLlPfuEfNgTI1IAYC8D7Tp7i+rR9+wZkX1Fznzu34cj/B8BkAUhM6C5fhE6/sezrPB1dxfv27Tt48GAryiowf6lg2rVrpwGJGhBBAKtv57Eu44NpXnnlYRW+ze62k/PbkCMByQDorgF6AVaf8verel9ZV2dmXTf5ezEfq/kTHwFITsYFdKfXAFuA7rt5FtdtWeZRlntGzE/VvKTGBsQhIIIWENCnZ17nRR3K74q2KausSb7E5sdq/kjDAVEAiBU3IBeg+ip/P+bl4eno78KoY4u0DPMqy8m5W85dd92FgBcJQDcA/Yg61gJ438qr+h9UW6RNmVdVTs8DarwMAIxXgFi2AKtv52Ud4jAyTm23zLM6+cDP+ViAOPjszxbg9k2ezi7qIq7OrdIm7Eb/bOaXOA5APIJiAVZfHV/m6fCmzto6bYWtJs6v1HgZAzUgLk7dgLwA3rfydHiqO3GTtsJu9RdmADCXAKnyBtgC3D48eioPh6ezm7qImzYvO9nr+AQC1AU4fXr0VF5unuombtqs7O/+yIwNiIyANwJsAbIv13+buHuZ99V13LSdsMn+Rs3TEpAGAHoEQvX18Vle1dXRVdzfdsNPi/kZjA2I4AC8ANaX2w/KO3HetsumK6dXLw2AF4F4BCrq06On825dxe12ULmXmHtgHIBeAF2A24cXXnDe1EO07fI9em68UQFSu2drAFuA7os89WXeqeujO20rzcJqLIC5AbmA55+nPj++P8/PruPs3Fb6RjaP4xgAPoNqAbVUv29AXyyf8vrwvjo7tz/9uJqnnnrKG64B4gbEAswFqP4zKn+3nXfr+uSBbVamuf12CUjkAL2Avub+nzHHD8izuj65G/elxTgbEDeACxAPQIi+P8/q5ujB7dutEYC0tNTsuKAFsH6IvDy8r27HA9q/EyMBiRyAL4FL9HneHN49Oo8HtGFGjCBAMgPQDcAC6ALg5w/vh8zze684ztJiFKA7/RTAR4BugBaALwDTt4+v887hWd2N+9ojRkyaNIkAA+gZjIiQN0ALUBfg9HX+OjsfWPfHrTYNB4gbkAugC4D+x9QX128f38mHrPvik/gogH4EGtfSC4ALkH08v1y/yYu77+XmA+vBcZx/AeDdATn/vA1ZAAAAAElFTkSuQmCC";class it{get diffuse(){return this._diffuse}get specular(){return this._specular}constructor(e,t){this._diffuse=e,this._specular=t}get valid(){return this._diffuse.valid&&this._specular.valid&&(!this.lookupBrdf||this.lookupBrdf.valid)}}it.defaultLookupBrdf=p.Texture.from(En,{mipmap:C.MIPMAP_MODES.OFF});const at={},jt=r=>r?r.lights.length+(r.imageBasedLighting?.5:0):0;class ie extends Ce{constructor(){super(...arguments),this._lightingEnvironmentConfigId=0,this._unlit=!1,this._alphaMode=oe.blend,this._baseColorFactor=new Float32Array(4),this._instancingEnabled=!1,this._skinUniforms=new yn,this.roughness=1,this.metallic=1,this.baseColor=new K(1,1,1,1),this.alphaCutoff=.5,this.emissive=new K(0,0,0),this.exposure=1}get baseColorTexture(){return this._baseColorTexture}set baseColorTexture(e){e!==this._baseColorTexture&&(this.invalidateShader(),!(e!=null&&e.transform)&&(e==null?void 0:e.frame)&&!(e!=null&&e.noFrame)&&(e.transform=he.fromTexture(e)),this._baseColorTexture=e)}get metallicRoughnessTexture(){return this._metallicRoughnessTexture}set metallicRoughnessTexture(e){e!==this._metallicRoughnessTexture&&(this.invalidateShader(),!(e!=null&&e.transform)&&(e==null?void 0:e.frame)&&!(e!=null&&e.noFrame)&&(e.transform=he.fromTexture(e)),this._metallicRoughnessTexture=e)}get normalTexture(){return this._normalTexture}set normalTexture(e){e!==this._normalTexture&&(this.invalidateShader(),!(e!=null&&e.transform)&&(e==null?void 0:e.frame)&&!(e!=null&&e.noFrame)&&(e.transform=he.fromTexture(e)),this._normalTexture=e)}get occlusionTexture(){return this._occlusionTexture}set occlusionTexture(e){e!==this._occlusionTexture&&(this.invalidateShader(),!(e!=null&&e.transform)&&(e==null?void 0:e.frame)&&!(e!=null&&e.noFrame)&&(e.transform=he.fromTexture(e)),this._occlusionTexture=e)}get emissiveTexture(){return this._emissiveTexture}set emissiveTexture(e){e!==this._emissiveTexture&&(this.invalidateShader(),!(e!=null&&e.transform)&&(e==null?void 0:e.frame)&&!(e!=null&&e.noFrame)&&(e.transform=he.fromTexture(e)),this._emissiveTexture=e)}get alphaMode(){return this._alphaMode}set alphaMode(e){this._alphaMode!==e&&(this._alphaMode=e,this.invalidateShader())}get shadowCastingLight(){return this._shadowCastingLight}set shadowCastingLight(e){e!==this._shadowCastingLight&&(this.invalidateShader(),this._shadowCastingLight=e)}get debugMode(){return this._debugMode}set debugMode(e){this._debugMode!==e&&(this.invalidateShader(),this._debugMode=e)}get lightingEnvironment(){return this._lightingEnvironment}set lightingEnvironment(e){e!==this._lightingEnvironment&&(this.invalidateShader(),this._lightingEnvironmentConfigId=jt(e),this._lightingEnvironment=e)}get unlit(){return this._unlit}set unlit(e){this._unlit!==e&&(this._unlit=e,this.invalidateShader())}destroy(){var e,t,n,i,a;(e=this._baseColorTexture)==null||e.destroy(),(t=this._normalTexture)==null||t.destroy(),(n=this._emissiveTexture)==null||n.destroy(),(i=this._occlusionTexture)==null||i.destroy(),(a=this._metallicRoughnessTexture)==null||a.destroy(),this._skinUniforms.destroy()}invalidateShader(){this._shader=void 0}static create(e){return new zt().create(e)}render(e,t){!this._instancingEnabled&&e.instances.length>0&&(this.invalidateShader(),this._instancingEnabled=!0),this._instancingEnabled&&e.instances.length===0&&(this.invalidateShader(),this._instancingEnabled=!1);let n=this.lightingEnvironment||fe.main,i=jt(n);i!==this._lightingEnvironmentConfigId&&(this.invalidateShader(),this._lightingEnvironmentConfigId=i),super.render(e,t)}get isInstancingSupported(){return!0}createInstance(){return new Dt(this)}createShader(e,t){if(t.context.webGLVersion===1){let s=["EXT_shader_texture_lod","OES_standard_derivatives"];for(let o of s)t.gl.getExtension(o)}let n=this.lightingEnvironment||fe.main,i=Ue.build(t,e,e.geometry,this,n);if(!i)return;e.skin&&Ue.hasSkinningTextureFeature(i)&&this._skinUniforms.enableJointMatrixTextures(e.skin.joints.length);let a=i.join(",");return at[a]||(at[a]=nt.build(t,i)),at[a]}updateUniforms(e,t){var n,i,a,s,o;for(let d=0;d<3;d++)this._baseColorFactor[d]=this.baseColor.rgba[d];this._baseColorFactor[3]=this.baseColor.a*e.worldAlpha;let h=this.camera||k.main;e.skin&&this._skinUniforms.update(e,t),t.uniforms.u_Camera=h.worldTransform.position.array,t.uniforms.u_ViewProjectionMatrix=h.viewProjection.array,t.uniforms.u_ViewMatrix=h.view.array,t.uniforms.u_Exposure=this.exposure,t.uniforms.u_MetallicFactor=this.metallic,t.uniforms.u_RoughnessFactor=this.roughness,t.uniforms.u_BaseColorFactor=this._baseColorFactor,t.uniforms.u_ModelMatrix=e.worldTransform.array,t.uniforms.u_NormalMatrix=e.transform.normalTransform.array,this._alphaMode===oe.mask&&(t.uniforms.u_AlphaCutoff=this.alphaCutoff),e.targetWeights&&e.targetWeights.length>0&&(t.uniforms.u_morphWeights=e.targetWeights),(n=this.baseColorTexture)!=null&&n.valid&&(t.uniforms.u_BaseColorSampler=this.baseColorTexture,t.uniforms.u_BaseColorUVSet=this.baseColorTexture.uvSet||0,this.baseColorTexture.transform&&(t.uniforms.u_BaseColorUVTransform=this.baseColorTexture.transform.array));let l=this.lightingEnvironment||fe.main;for(let d=0;d<l.lights.length;d++){let c=l.lights[d],f=0;switch(c.type){case re.point:f=1;break;case re.directional:f=0;break;case re.spot:f=2;break}t.uniforms[`u_Lights[${d}].type`]=f,t.uniforms[`u_Lights[${d}].position`]=c.worldTransform.position.array,t.uniforms[`u_Lights[${d}].direction`]=c.worldTransform.forward.array,t.uniforms[`u_Lights[${d}].range`]=c.range,t.uniforms[`u_Lights[${d}].color`]=c.color.rgb,t.uniforms[`u_Lights[${d}].intensity`]=c.intensity,t.uniforms[`u_Lights[${d}].innerConeCos`]=Math.cos(c.innerConeAngle*H.DEG_TO_RAD),t.uniforms[`u_Lights[${d}].outerConeCos`]=Math.cos(c.outerConeAngle*H.DEG_TO_RAD)}l.fog&&(t.uniforms.u_FogNear=l.fog.near,t.uniforms.u_FogFar=l.fog.far,t.uniforms.u_FogColor=l.fog.color.rgb),this._shadowCastingLight&&(t.uniforms.u_ShadowSampler=this._shadowCastingLight.shadowTexture,t.uniforms.u_LightViewProjectionMatrix=this._shadowCastingLight.lightViewProjection,t.uniforms.u_ShadowLightIndex=l.lights.indexOf(this._shadowCastingLight.light));let u=l.imageBasedLighting;u!=null&&u.valid&&(t.uniforms.u_DiffuseEnvSampler=u.diffuse,t.uniforms.u_SpecularEnvSampler=u.specular,t.uniforms.u_brdfLUT=u.lookupBrdf||it.defaultLookupBrdf,t.uniforms.u_MipCount=u.specular.levels-1),(i=this.emissiveTexture)!=null&&i.valid&&(t.uniforms.u_EmissiveSampler=this.emissiveTexture,t.uniforms.u_EmissiveUVSet=this.emissiveTexture.uvSet||0,t.uniforms.u_EmissiveFactor=this.emissive.rgb,this.emissiveTexture.transform&&(t.uniforms.u_EmissiveUVTransform=this.emissiveTexture.transform.array)),(a=this.normalTexture)!=null&&a.valid&&(t.uniforms.u_NormalSampler=this.normalTexture,t.uniforms.u_NormalScale=this.normalTexture.scale||1,t.uniforms.u_NormalUVSet=this.normalTexture.uvSet||0,this.normalTexture.transform&&(t.uniforms.u_NormalUVTransform=this.normalTexture.transform.array)),(s=this.metallicRoughnessTexture)!=null&&s.valid&&(t.uniforms.u_MetallicRoughnessSampler=this.metallicRoughnessTexture,t.uniforms.u_MetallicRoughnessUVSet=this.metallicRoughnessTexture.uvSet||0,this.metallicRoughnessTexture.transform&&(t.uniforms.u_MetallicRoughnessUVTransform=this.metallicRoughnessTexture.transform.array)),(o=this.occlusionTexture)!=null&&o.valid&&(t.uniforms.u_OcclusionSampler=this.occlusionTexture,t.uniforms.u_OcclusionStrength=this.occlusionTexture.strength||1,t.uniforms.u_OcclusionUVSet=this.occlusionTexture.uvSet||0,this.occlusionTexture.transform&&(t.uniforms.u_OcclusionUVTransform=this.occlusionTexture.transform.array))}}class Ie{constructor(){this._onChanged=()=>{this._center.set((this._min.x+this._max.x)/2,(this._min.y+this._max.y)/2,(this._min.z+this._max.z)/2),this._extents.set(Math.abs(this._max.x-this._center.x),Math.abs(this._max.y-this._center.y),Math.abs(this._max.z-this._center.z)),this._size.set(this._extents.x*2,this._extents.y*2,this._extents.z*2)},this._min=new b(0,0,0,this._onChanged,this),this._max=new b(0,0,0,this._onChanged,this),this._center=new b(0,0,0,()=>{},this),this._size=new b(0,0,0,()=>{},this),this._extents=new b(0,0,0,()=>{},this)}get min(){return this._min}set min(e){this._min.copyFrom(e)}get max(){return this._max}set max(e){this._max.copyFrom(e)}get center(){return this._center}get size(){return this._size}get extents(){return this._extents}static from(e){let t=new Ie;return t.min.setFrom(e.min),t.max.setFrom(e.max),t}encapsulate(e){this._min.x=Math.min(this._min.x,e.x),this._min.y=Math.min(this._min.y,e.y),this._min.z=Math.min(this._min.z,e.z),this._max.x=Math.max(this._max.x,e.x),this._max.y=Math.max(this._max.y,e.y),this._max.z=Math.max(this._max.z,e.z)}}class bn{static create(e={}){var t,n,i,a;const s=(t=e==null?void 0:e.radius)!=null?t:1,o=Math.max(3,Math.floor((n=e==null?void 0:e.segments)!=null?n:32)),h=(i=e==null?void 0:e.thetaStart)!=null?i:0,l=(a=e==null?void 0:e.thetaLength)!=null?a:Math.PI*2,u=[],d=[],c=[],f=[],_=x.create(),m=x.create();d.push(0,0,0),c.push(0,0,1),f.push(.5,.5);for(let g=0,A=3;g<=o;g+=1,A+=3){const M=h+g/o*l;_[0]=s*Math.cos(M),_[1]=s*Math.sin(M),d.push(_[0],_[1],_[2]),c.push(0,0,1),m[0]=(d[A]/s+1)/2,m[1]=(d[A+1]/s+1)/2,f.push(m[0],m[1])}for(let g=1;g<=o;g+=1)u.push(g,g+1,0);return Object.assign(new ce,{normals:{buffer:new Float32Array(c)},uvs:[{buffer:new Float32Array(f)}],indices:{buffer:new Uint16Array(u)},positions:{buffer:new Float32Array(d)}})}}class Mn{static create(e={}){var t,n,i,a,s,o,h,l;const u=(t=e==null?void 0:e.radiusTop)!=null?t:1,d=(n=e==null?void 0:e.radiusBottom)!=null?n:1,c=(i=e==null?void 0:e.height)!=null?i:1,f=Math.floor((a=e==null?void 0:e.radialSegments)!=null?a:32),_=Math.floor((s=e==null?void 0:e.heightSegments)!=null?s:1),m=(o=e==null?void 0:e.openEnded)!=null?o:!1,g=(h=e==null?void 0:e.thetaStart)!=null?h:0,A=(l=e==null?void 0:e.thetaLength)!=null?l:Math.PI*2,M=[],w=[],S=[],y=[];let E=0;const B=[],z=c/2,Y=()=>{const G=(d-u)/c;for(let F=0;F<=_;F+=1){const L=[],R=F/_,Z=R*(d-u)+u;for(let V=0;V<=f;V+=1){const ne=V/f,se=ne*A+g,Fe=Math.sin(se),We=Math.cos(se),vt=Z*Fe,At=-R*c+z,Tt=Z*We;w.push(vt,At,Tt);const xt=Fe,_i=G,gi=We,wt=x.normalize(x.fromValues(xt,_i,gi));y.push(wt[0],wt[1],wt[2]),S.push(ne,1-R),L.push(E),E+=1}B.push(L)}for(let F=0;F<f;F+=1)for(let L=0;L<_;L+=1){const R=B[L][F],Z=B[L+1][F],V=B[L+1][F+1],ne=B[L][F+1];M.push(R,Z,ne),M.push(Z,V,ne)}},Q=G=>{const F=E,L=G===!0?u:d,R=G===!0?1:-1;for(let V=1;V<=f;V+=1)w.push(0,z*R,0),y.push(0,R,0),S.push(.5,.5),E+=1;const Z=E;for(let V=0;V<=f;V+=1){const ne=V/f*A+g,se=Math.cos(ne),Fe=Math.sin(ne),We=L*Fe,vt=z*R,At=L*se;w.push(We,vt,At),y.push(0,R,0);const Tt=se*.5+.5,xt=Fe*.5*R+.5;S.push(Tt,xt),E+=1}for(let V=0;V<f;V+=1){const ne=F+V,se=Z+V;G===!0?M.push(se,se+1,ne):M.push(se+1,se,ne)}};return Y(),m===!1&&(u>0&&Q(!0),d>0&&Q(!1)),Object.assign(new ce,{normals:{buffer:new Float32Array(y)},uvs:[{buffer:new Float32Array(S)}],indices:{buffer:new Uint16Array(M)},positions:{buffer:new Float32Array(w)}})}}var st;(r=>{function e(t={}){const{radius:n=1,segments:i=32,rings:a=16}=t,s=[],o=[],h=[],l=[],u=[];let d=0;for(let c=0;c<=a;c++){const f=[],_=c/a;let m=0;c==0?m=.5/i:c==a&&(m=-.5/i);for(let g=0;g<=i;g++){const A=g/i;let M=-n*Math.cos(A*Math.PI*2)*Math.sin(_*Math.PI),w=n*Math.cos(_*Math.PI),S=n*Math.sin(A*Math.PI*2)*Math.sin(_*Math.PI),y=x.fromValues(M,w,S);h.push(M,w,S),u.push(...x.normalize(y)),l.push(A+m,1-_),f.push(d++)}s.push(f)}for(let c=0;c<a;c++)for(let f=0;f<i;f++){const _=s[c][f+1],m=s[c][f],g=s[c+1][f],A=s[c+1][f+1];c!==0&&o.push(_,m,A),c!==a-1&&o.push(m,g,A)}return Object.assign(new ce,{normals:{buffer:new Float32Array(u)},uvs:[{buffer:new Float32Array(l)}],indices:{buffer:new Uint16Array(o)},positions:{buffer:new Float32Array(h)}})}r.create=e})(st||(st={}));class q extends J{constructor(e,t){if(super(),this.geometry=e,this.material=t,this.pluginName="pipeline",this.enabledRenderPasses={material:{}},this.renderSortOrder=0,this._instances=[],!e)throw new Error("PIXI3D: Geometry is required when creating a mesh.")}get instances(){return this._instances}createInstance(){var e;if(this.material&&!this.material.isInstancingSupported)throw new Error("PIXI3D: Can't create instance of mesh, material does not support instancing.");return this._instances[this._instances.push(new Tn(this,(e=this.material)==null?void 0:e.createInstance()))-1]}removeInstance(e){const t=this._instances.indexOf(e);t>=0&&this._instances.splice(t,1)}enableRenderPass(e,t){this.enabledRenderPasses[e]||(this.enabledRenderPasses[e]=t||{})}disableRenderPass(e){this.enabledRenderPasses[e]&&delete this.enabledRenderPasses[e]}isRenderPassEnabled(e){return!!this.enabledRenderPasses[e]}destroy(e){(e===!0||e&&e.geometry)&&this.geometry.destroy(),(e===!0||e&&e.material)&&this.material&&this.material.destroy(),super.destroy(e)}_render(e){e.batch.setObjectRenderer(e.plugins[this.pluginName]),this.skin&&this.skin.calculateJointMatrices(),e.plugins[this.pluginName].render(this)}getBoundingBox(){var e,t;if(!((e=this.geometry.positions)!=null&&e.min)||!((t=this.geometry.positions)!=null&&t.max))return;let n=x.transformMat4(this.geometry.positions.min,this.worldTransform.array),i=x.transformMat4(this.geometry.positions.max,this.worldTransform.array);for(let a=0;a<3;a++){let s=n[a];n[a]=Math.min(n[a],i[a]),i[a]=Math.max(s,i[a])}return Ie.from({min:n,max:i})}static createQuad(e=new ie){return new q(tt.create(),e)}static createCube(e=new ie){return new q(et.create(),e)}static createPlane(e=new ie){return new q($e.create(),e)}static createSphere(e=new ie,t){return new q(st.create(t),e)}static createCircle(e=new ie,t={}){return new q(bn.create(t),e)}static createCylinder(e=new ie,t={}){return new q(Mn.create(t),e)}}class kt extends Xe.EventEmitter{constructor(e){super(),this.name=e,this.speed=1,this.loop=!1}play(e=ge.Ticker.shared){this.position=0,this._ticker||(this._update=()=>{this.update(e.deltaMS/1e3*this.speed)},this._ticker=e.add(this._update))}stop(){this._ticker&&this._update&&(this._ticker.remove(this._update),this._ticker=this._update=void 0)}update(e){this.position+=e,!(this.position<this.duration)&&(this.loop?this.position>this.duration&&(this.position=this.position%this.duration):(this.position=this.duration,this.stop()),this.emit("complete"))}}class Rn extends kt{constructor(e,t){super(t),this._duration=0,this._position=0,this._channels=[];for(let n of e)this._duration=Math.max(this._duration,n.duration);this._channels=e}get duration(){return this._duration}get position(){return this._position}set position(e){this._position=e;for(let t of this._channels)t.position=this._position}}class me{constructor(e,t,n=0,i,a=!1,s,o){this.buffer=e,this.componentType=t,this.stride=n,this.componentCount=i,this.normalized=a,this.min=s,this.max=o}static from(e,t,n,i,a,s,o=!1,h,l){switch(e){case 5125:return new me(new Uint32Array(n,i,a),e,s,t,o,h,l);case 5126:return new me(new Float32Array(n,i,a),e,s,t,o,h,l);case 5120:return new me(new Int8Array(n,i,a),e,s,t,o,h,l);case 5121:return new me(new Uint8Array(n,i,a),e,s,t,o,h,l);case 5122:return new me(new Int16Array(n,i,a),e,s,t,o,h,l);case 5123:return new me(new Uint16Array(n,i,a),e,s,t,o,h,l);default:throw new Error(`PIXI3D: Unknown component type "${e}".`)}}}class Qt{constructor(e,t){this.parent=e,this.joints=t,this._jointMatrices=[],this._jointNormalMatrices=[],this._transformIds=[],this.jointNormalMatrices=new Float32Array(this.joints.length*16),this.jointMatrices=new Float32Array(this.joints.length*16);for(let n=0;n<t.length;n++)this._transformIds.push(-1),this._jointMatrices.push(new Float32Array(this.jointMatrices.buffer,64*n,16)),this._jointNormalMatrices.push(new Float32Array(this.jointNormalMatrices.buffer,64*n,16))}calculateJointMatrices(){for(let e=0;e<this.joints.length;e++)this.joints[e].transform._worldID!==this._transformIds[e]&&(this._transformIds[e]=this.joints[e].transform._worldID,T.multiply(this.joints[e].worldTransform.array,this.joints[e].inverseBindMatrix,this._jointMatrices[e]),T.multiply(this.parent.transform.inverseWorldTransform.array,this._jointMatrices[e],this._jointMatrices[e]),T.invert(this._jointMatrices[e],this._jointNormalMatrices[e]),T.transpose(this._jointNormalMatrices[e],this._jointNormalMatrices[e]))}}class Wt extends J{constructor(e){super(),this.inverseBindMatrix=e}}function ot(r,e){switch(r.constructor){case Float32Array:return t=>t;case Uint32Array:return t=>{for(let n=0;n<e;n++)t[n]=t[n]/4294967295;return t};case Uint16Array:return t=>{for(let n=0;n<e;n++)t[n]=t[n]/65535;return t};case Uint8Array:return t=>{for(let n=0;n<e;n++)t[n]=t[n]/255;return t};case Int32Array:return t=>{for(let n=0;n<e;n++)t[n]=Math.max(t[n]/2147483647,-1);return t};case Int16Array:return t=>{for(let n=0;n<e;n++)t[n]=Math.max(t[n]/32767,-1);return t};case Int8Array:return t=>{for(let n=0;n<e;n++)t[n]=Math.max(t[n]/127,-1);return t};default:throw new Error("Invalid component type.")}}class Cn{constructor(e,t){this._output=e,this._stride=t,this._data=new Float32Array(t),this._denormalize=ot(this._output,this._stride)}interpolate(e,t){let n=(e+0)*this._stride,i=(e+1)*this._stride;for(let a=0;a<this._stride;a++)this._output.length>i?this._data[a]=(1-t)*this._output[n+a]+t*this._output[i+a]:this._data[a]=this._output[n+a];return this._denormalize(this._data)}}class lt{constructor(e,t,n){this._input=e,this._output=t,this._stride=n,this._data=new Float32Array(n),this._denormalize=ot(this._output,this._stride)}interpolate(e,t){const n=this._input[e+1]-this._input[e],i=(e+0)*this._stride*3,a=(e+1)*this._stride*3;for(let s=0;s<this._stride;s++)this._data[s]=lt.calculate(t,this._output[i+s+1*this._stride],this._output[a+s+1*this._stride],n*this._output[a+s],n*this._output[i+s+2*this._stride]);return this._denormalize(this._data)}static calculate(e,t,n,i,a){return(2*e**3-3*e**2+1)*t+(e**3-2*e**2+e)*i+(-2*e**3+3*e**2)*n+(e**3-e**2)*a}}class In{constructor(e,t){this._output=e,this._stride=t,this._data=new Float32Array(t),this._denormalize=ot(this._output,this._stride)}interpolate(e){for(let t=0;t<this._stride;t++)this._data[t]=this._output[e*this._stride+t];return this._denormalize(this._data)}}class De{static create(e,t,n,i){switch(e){case"LINEAR":return new Cn(n,i);case"CUBICSPLINE":return new lt(t,n,i);case"STEP":return new In(n,i)}throw new Error(`PIXI3D: Unknown interpolation type "${e}"`)}}class Be{constructor(e,t){this._position=0,this._frame=0,this._input=e,this._interpolation=t}get position(){return this._position}set position(e){this.setPosition(e)}get duration(){return this._input[this._input.length-1]}get frame(){return this._frame}get length(){return this._input.length}setPosition(e){this._position=e,this._frame=this.calculateFrame(this._position),this.updateTarget(this._interpolation.interpolate(this._frame,this.calculateFramePosition(this._frame,this._position)))}update(e){this.position+=e}calculateFramePosition(e,t){return e===this._input.length-1?1:(t-this._input[e])/(this._input[e+1]-this._input[e])}calculateFrame(e){if(e<this._input[0])return 0;for(let t=0;t<this._input.length-1;t++)if(e>=this._input[t]&&e<this._input[t+1])return t;return this._input.length-1}}class Xt extends Be{constructor(e,t,n){super(t,n),this._transform=e}updateTarget(e){this._transform.rotationQuaternion.set(e[0],e[1],e[2],e[3])}}class Nn extends Be{constructor(e,t,n){super(t,n),this._transform=e}updateTarget(e){this._transform.scale.set(e[0],e[1],e[2])}}class Fn{constructor(e){this._output=e,this._data=new Float32Array(4)}interpolate(e,t){let n=(e+0)*4,i=(e+1)*4,a=D.set(this._output[n],this._output[n+1],this._output[n+2],this._output[n+3],new Float32Array(4));if(this._output.length<=i)return D.normalize(a,this._data);let s=D.set(this._output[i],this._output[i+1],this._output[i+2],this._output[i+3],new Float32Array(4));return D.normalize(D.slerp(a,s,t,this._data),this._data)}}class Ln extends Be{constructor(e,t,n){super(t,n),this._transform=e}updateTarget(e){this._transform.position.set(e[0],e[1],e[2])}}class Pn extends Be{constructor(e,t,n){super(t,n),this._weights=e}updateTarget(e){for(let t=0;t<e.length;t++)this._weights[t]=e[t]}}class On{static create(e,t,n,i,a){if(i==="translation")return new Ln(a.transform,e,De.create(n,e,t,3));if(i==="scale")return new Nn(a.transform,e,De.create(n,e,t,3));if(i==="rotation")return n==="LINEAR"?new Xt(a.transform,e,new Fn(t)):new Xt(a.transform,e,De.create(n,e,t,4));if(i==="weights"){let s=a.children[0].targetWeights;return s?new Pn(s,e,De.create(n,e,t,s.length)):void 0}throw new Error(`PIXI3D: Unknown channel path "${i}"`)}}class Ge{constructor(e,t){var n;if(this._asset=e,this._materialFactory=t||new zt,this._descriptor=this._asset.descriptor,e.textures.length===0)for(let i=0;i<((n=this._descriptor.textures)==null?void 0:n.length);i++)e.textures.push(this.parseTexture(i))}static createModel(e,t){return new Ge(e,t).parseModel()}static createMesh(e,t,n=0){return new Ge(e,t).parseMesh(n)}parseBuffer(e){if(e===void 0)return;typeof e=="number"&&(e=this._asset.descriptor.accessors[e]);let t=this._descriptor.bufferViews[e.bufferView||0],n=e.byteOffset||0;t.byteOffset!==void 0&&(n+=t.byteOffset);let i=e.count*ht[e.type];t.byteStride!==void 0&&t.byteStride!==0&&(i=t.byteStride/Un[e.componentType]*(e.count-1)+ht[e.type]);let a=this._asset.buffers[t.buffer];const s=e.normalized===!0;return me.from(e.componentType,ht[e.type],a,n,i,t.byteStride,s,e.min,e.max)}parseAnimation(e,t){typeof e=="number"&&(e=this._asset.descriptor.animations[e]);let n=[];for(let i of e.channels){let a=e.samplers[i.sampler],s=this.parseBuffer(a.input);if(s===void 0)continue;let o=this.parseBuffer(a.output);if(o===void 0)continue;let h=On.create(s.buffer,o.buffer,a.interpolation||"LINEAR",i.target.path,t[i.target.node]);h&&n.push(h)}return new Rn(n,e.name)}parseMaterial(e){typeof e=="number"&&(e=this._asset.descriptor.materials[e]);let t=new Bt;if(!e)return this._materialFactory.create(t);e.occlusionTexture!==void 0&&(t.occlusionTexture=this._asset.textures[e.occlusionTexture.index].clone(),t.occlusionTexture.strength=e.occlusionTexture.strength,t.occlusionTexture.texCoord=e.occlusionTexture.texCoord,e.occlusionTexture.extensions&&e.occlusionTexture.extensions.KHR_texture_transform&&(t.occlusionTexture.transform=e.occlusionTexture.extensions.KHR_texture_transform,e.occlusionTexture.extensions.KHR_texture_transform.texCoord!==void 0&&(t.occlusionTexture.texCoord=e.occlusionTexture.extensions.KHR_texture_transform.texCoord))),e.normalTexture!==void 0&&(t.normalTexture=this._asset.textures[e.normalTexture.index].clone(),t.normalTexture.scale=e.normalTexture.scale||1,t.normalTexture.texCoord=e.normalTexture.texCoord,e.normalTexture.extensions&&e.normalTexture.extensions.KHR_texture_transform&&(t.normalTexture.transform=e.normalTexture.extensions.KHR_texture_transform,e.normalTexture.extensions.KHR_texture_transform.texCoord!==void 0&&(t.normalTexture.texCoord=e.normalTexture.extensions.KHR_texture_transform.texCoord))),e.emissiveTexture!==void 0&&(t.emissiveTexture=this._asset.textures[e.emissiveTexture.index].clone(),t.emissiveTexture.texCoord=e.emissiveTexture.texCoord,e.emissiveTexture.extensions&&e.emissiveTexture.extensions.KHR_texture_transform&&(t.emissiveTexture.transform=e.emissiveTexture.extensions.KHR_texture_transform,e.emissiveTexture.extensions.KHR_texture_transform.texCoord!==void 0&&(t.emissiveTexture.texCoord=e.emissiveTexture.extensions.KHR_texture_transform.texCoord))),e.doubleSided!==void 0&&(t.doubleSided=e.doubleSided),e.emissiveFactor&&(t.emissiveFactor=e.emissiveFactor),e.alphaMode&&(t.alphaMode=e.alphaMode),e.alphaCutoff!==void 0&&(t.alphaCutoff=e.alphaCutoff);let n=e.pbrMetallicRoughness;return(n==null?void 0:n.metallicRoughnessTexture)!==void 0&&(t.metallicRoughnessTexture=this._asset.textures[n.metallicRoughnessTexture.index].clone(),t.metallicRoughnessTexture.texCoord=n.metallicRoughnessTexture.texCoord,n.metallicRoughnessTexture.extensions&&n.metallicRoughnessTexture.extensions.KHR_texture_transform&&(t.metallicRoughnessTexture.transform=n.metallicRoughnessTexture.extensions.KHR_texture_transform,n.metallicRoughnessTexture.extensions.KHR_texture_transform.texCoord!==void 0&&(t.metallicRoughnessTexture.texCoord=n.metallicRoughnessTexture.extensions.KHR_texture_transform.texCoord))),n!=null&&n.baseColorFactor&&(t.baseColor=n.baseColorFactor),(n==null?void 0:n.baseColorTexture)!==void 0&&(t.baseColorTexture=this._asset.textures[n.baseColorTexture.index].clone(),t.baseColorTexture.texCoord=n.baseColorTexture.texCoord,n.baseColorTexture.extensions&&n.baseColorTexture.extensions.KHR_texture_transform&&(t.baseColorTexture.transform=n.baseColorTexture.extensions.KHR_texture_transform,n.baseColorTexture.extensions.KHR_texture_transform.texCoord!==void 0&&(t.baseColorTexture.texCoord=n.baseColorTexture.extensions.KHR_texture_transform.texCoord))),(n==null?void 0:n.metallicFactor)!==void 0&&(t.metallic=n.metallicFactor),(n==null?void 0:n.roughnessFactor)!==void 0&&(t.roughness=n.roughnessFactor),e.extensions&&(t.unlit=e.extensions.KHR_materials_unlit!==void 0),this._materialFactory.create(t)}parseTexture(e){const t=this._descriptor.textures[e],n=this._asset.images[t.source],i=new p.Texture(new p.BaseTexture(n.baseTexture.resource,{wrapMode:C.WRAP_MODES.REPEAT,alphaMode:C.ALPHA_MODES.NO_PREMULTIPLIED_ALPHA}));if(this._descriptor.samplers&&t.sampler!==void 0)switch(this._descriptor.samplers[t.sampler].wrapS){case 10497:i.baseTexture.wrapMode=C.WRAP_MODES.REPEAT;break;case 33648:i.baseTexture.wrapMode=C.WRAP_MODES.MIRRORED_REPEAT;break;case 33071:i.baseTexture.wrapMode=C.WRAP_MODES.CLAMP;break}return i}parseMesh(e){typeof e=="number"&&(e=this._asset.descriptor.meshes[e]);let t=e.weights||[];return e.primitives.map(n=>Object.assign(this.parsePrimitive(n),{name:e.name,targetWeights:t}))}parseSkin(e,t,n){return typeof e=="number"&&(e=this._asset.descriptor.skins[e]),new Qt(t,e.joints.map(i=>n[i]))}parsePrimitive(e){let{attributes:t,targets:n}=e,i=Object.assign(new ce,{indices:this.parseBuffer(e.indices),positions:this.parseBuffer(t.POSITION),normals:this.parseBuffer(t.NORMAL),tangents:this.parseBuffer(t.TANGENT),joints:this.parseBuffer(t.JOINTS_0),weights:this.parseBuffer(t.WEIGHTS_0),colors:this.parseBuffer(t.COLOR_0)});for(let s=0;;s++){let o=this.parseBuffer(t[`TEXCOORD_${s}`]);if(o===void 0)break;i.uvs=i.uvs||[],i.uvs.push(o)}if(n)for(let s=0;s<n.length;s++)i.targets=i.targets||[],i.targets.push({positions:this.parseBuffer(n[s].POSITION),normals:this.parseBuffer(n[s].NORMAL),tangents:this.parseBuffer(n[s].TANGENT)});let a;return e.material!==void 0?a=this.parseMaterial(this._asset.descriptor.materials[e.material]):a=this.parseMaterial(),new q(i,a)}parseNode(e){const t=this._asset.descriptor.nodes[e];let n;for(let a of this._asset.descriptor.skins||[]){const s=a.joints.indexOf(e);if(s>=0){const o=this.parseBuffer(a.inverseBindMatrices),h=o==null?void 0:o.buffer.slice(s*16,s*16+16);n=Object.assign(new Wt(h),{name:t.name})}}let i=n||Object.assign(new J,{name:t.name});return t.translation&&i.position.set(t.translation[0],t.translation[1],t.translation[2]),t.rotation&&i.rotationQuaternion.set(t.rotation[0],t.rotation[1],t.rotation[2],t.rotation[3]),t.scale&&i.scale.set(t.scale[0],t.scale[1],t.scale[2]),t.matrix&&i.transform.setFromMatrix(new I(t.matrix)),i}parseModel(){let e=this._descriptor.nodes.map((a,s)=>this.parseNode(s)),t=this._descriptor.scenes[this._asset.descriptor.scene||0],n=new Ve,i=(a,s)=>{let o=this._asset.descriptor.nodes[s].mesh,h;if(this._asset.descriptor.nodes[s].skin!==void 0&&(h=this.parseSkin(this._asset.descriptor.nodes[s].skin,e[s],e)),o!==void 0)for(let l of this.parseMesh(o))n.meshes.push(e[s].addChild(l)),n.meshes[n.meshes.length-1].skin=h;if(a.addChild(e[s]),!!this._asset.descriptor.nodes[s].children)for(let l of this._asset.descriptor.nodes[s].children)i(e[s],l)};for(let a of t.nodes)i(n,a);if(this._asset.descriptor.animations)for(let a of this._asset.descriptor.animations)n.animations.push(this.parseAnimation(a,e));return n}}const ht={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},Un={[5120]:1,[5121]:1,[5122]:2,[5123]:2,[5125]:4,[5126]:4};function Jt(r,e,t){for(let n of r.children)if(n instanceof q){const i=n.createInstance();i.name=n.name,t.push(e.addChild(i))}else if(n instanceof J){const i=e.addChild(new J);i.name=r.name,i.position=n.position,i.scale=n.scale,i.rotationQuaternion=n.rotationQuaternion,Jt(n,i,t)}}class Kt extends J{constructor(e){super(),this.meshes=[],Jt(e,this,this.meshes)}}class Ve extends J{constructor(){super(...arguments),this.animations=[],this.meshes=[]}static from(e,t){return Ge.createModel(e,t)}createInstance(){return new Kt(this)}getBoundingBox(){this.updateTransform();let e=new Ie,t=this.meshes[0].getBoundingBox();t&&(e.min=t.min,e.max=t.max);for(let n=1;n<this.meshes.length;n++){let i=this.meshes[n].getBoundingBox();i&&(e.encapsulate(i.min),e.encapsulate(i.max))}return e}}class Dn extends J{constructor(){super(...arguments),this.type=re.point,this.color=new K(1,1,1),this.range=10,this.intensity=10,this.innerConeAngle=0,this.outerConeAngle=45}}class Bn{constructor(e=5,t=50,n=new K(1,1,1)){this.near=e,this.far=t,this.color=n}}class qt{constructor(e,t){this.renderer=e,this.name=t,this.clearColor=new K(0,0,0,0)}get renderTexture(){return this._renderTexture}set renderTexture(e){this._renderTexture=e}clear(){if(this._renderTexture&&this.clearColor){const e=this.renderer.renderTexture.current;this.renderer.renderTexture.bind(this._renderTexture),this.renderer.renderTexture.clear(Array.from(this.clearColor.rgba)),this.renderer.renderTexture.bind(e||void 0)}}render(e){const t=this.renderer.renderTexture.current;this._renderTexture&&this.renderer.renderTexture.bind(this._renderTexture);for(let n of e)n.material&&n.material.render(n,this.renderer);this._renderTexture&&this.renderer.renderTexture.bind(t||void 0)}}var Gn={source:`#version VERSION

VERT_IN vec3 a_Position;
VERT_IN vec2 a_UV1;

VERT_OUT vec2 v_UV1;

void main() {
  v_UV1 = a_UV1;
  gl_Position = vec4(a_Position, 1.0);
}`},Vn={source:`#version VERSION

#define FEATURES

#ifdef GL_FRAGMENT_PRECISION_HIGH
  precision highp float;
#else
  precision mediump float;
#endif

#ifdef WEBGL2
  out vec4 FRAG_COLOR;
#endif

FRAG_IN vec2 v_UV1;

uniform vec2 u_BlurScale;
uniform sampler2D u_FilterSampler;

void main() {
  vec4 color = vec4(0.0);

  color += texture2D(u_FilterSampler, v_UV1 + (vec2(-3.0) * u_BlurScale.xy)) * (1.0/64.0);
  color += texture2D(u_FilterSampler, v_UV1 + (vec2(-2.0) * u_BlurScale.xy)) * (6.0/64.0);
  color += texture2D(u_FilterSampler, v_UV1 + (vec2(-1.0) * u_BlurScale.xy)) * (15.0/64.0);
  color += texture2D(u_FilterSampler, v_UV1 + (vec2(+0.0) * u_BlurScale.xy)) * (20.0/64.0);
  color += texture2D(u_FilterSampler, v_UV1 + (vec2(+1.0) * u_BlurScale.xy)) * (15.0/64.0);
  color += texture2D(u_FilterSampler, v_UV1 + (vec2(+2.0) * u_BlurScale.xy)) * (6.0/64.0);
  color += texture2D(u_FilterSampler, v_UV1 + (vec2(+3.0) * u_BlurScale.xy)) * (1.0/64.0);

  FRAG_COLOR = color;
}`};class Hn{constructor(e){this.renderer=e,this._mesh=q.createQuad(),this._gaussianBlurShader=new Ae(p.Program.from(de.build(Gn.source,[],e),de.build(Vn.source,[],e)))}applyGaussianBlur(e){this.applyBlurScale(e.shadowTexture,e.filterTexture,new Float32Array([0,e.softness/e.shadowTexture.height])),this.applyBlurScale(e.filterTexture,e.shadowTexture,new Float32Array([e.softness/e.shadowTexture.width,0]))}applyBlurScale(e,t,n){this.renderer.renderTexture.bind(t),this.renderer.renderTexture.clear(),this._gaussianBlurShader.uniforms.u_FilterSampler=e,this._gaussianBlurShader.uniforms.u_BlurScale=n,this._gaussianBlurShader.render(this._mesh,this.renderer),this.renderer.renderTexture.bind(void 0)}}var zn={source:`#version VERSION

#define FEATURES

vec4 _texture(sampler2D sampler, vec2 coord)
{
#ifdef WEBGL2
    return texture(sampler, coord);
#else
    return texture2D(sampler, coord);
#endif
}

vec4 _texture(samplerCube sampler, vec3 coord)
{
#ifdef WEBGL2
    return texture(sampler, coord);
#else
    return textureCube(sampler, coord);
#endif
}

VERT_IN vec3 a_Position;

#ifdef USE_SKINNING
  VERT_IN vec4 a_Joint1;
  VERT_IN vec4 a_Weight1;
#endif

uniform mat4 u_ViewProjectionMatrix;
uniform mat4 u_ModelMatrix;

#ifdef USE_SKINNING
  #ifdef USE_SKINNING_TEXTURE
    uniform sampler2D u_jointMatrixSampler;
  #else
    uniform mat4 u_jointMatrix[MAX_JOINT_COUNT];
  #endif
#endif

#ifdef USE_INSTANCING
  VERT_IN vec4 a_ModelMatrix0;
  VERT_IN vec4 a_ModelMatrix1;
  VERT_IN vec4 a_ModelMatrix2;
  VERT_IN vec4 a_ModelMatrix3;
#endif

// these offsets assume the texture is 4 pixels across
#define ROW0_U ((0.5 + 0.0) / 4.0)
#define ROW1_U ((0.5 + 1.0) / 4.0)
#define ROW2_U ((0.5 + 2.0) / 4.0)
#define ROW3_U ((0.5 + 3.0) / 4.0)

#ifdef USE_SKINNING
mat4 getJointMatrix(float boneNdx) {
  #ifdef USE_SKINNING_TEXTURE
    float v = (boneNdx + 0.5) / float(MAX_JOINT_COUNT);
    return mat4(
      _texture(u_jointMatrixSampler, vec2(ROW0_U, v)), 
      _texture(u_jointMatrixSampler, vec2(ROW1_U, v)), 
      _texture(u_jointMatrixSampler, vec2(ROW2_U, v)), 
      _texture(u_jointMatrixSampler, vec2(ROW3_U, v))
    );
  #else
    return u_jointMatrix[int(boneNdx)];
  #endif
}

mat4 getSkinningMatrix() {
  mat4 skin = mat4(0);
  skin += 
    a_Weight1.x * getJointMatrix(a_Joint1.x) +
    a_Weight1.y * getJointMatrix(a_Joint1.y) +
    a_Weight1.z * getJointMatrix(a_Joint1.z) +
    a_Weight1.w * getJointMatrix(a_Joint1.w);
  return skin;
}
#endif

void main() {
  mat4 modelMatrix = u_ModelMatrix;
  #ifdef USE_INSTANCING
    modelMatrix = mat4(a_ModelMatrix0, a_ModelMatrix1, a_ModelMatrix2, a_ModelMatrix3);
  #endif
  vec4 pos = vec4(a_Position, 1.0);
  #ifdef USE_SKINNING
    pos = getSkinningMatrix() * pos;
  #endif
  gl_Position = u_ViewProjectionMatrix * modelMatrix * pos;
}`},jn={source:`#version VERSION

#define FEATURES

#if defined(WEBGL1)
  #extension GL_OES_standard_derivatives : enable
#endif

#ifdef GL_FRAGMENT_PRECISION_HIGH
  precision highp float;
#else
  precision mediump float;
#endif

#ifdef WEBGL2
  out vec4 FRAG_COLOR;
#endif

void main() {
  float depth = gl_FragCoord.z;
  float dx = 0.0;
  float dy = 0.0;

  #if defined(WEBGL2) || defined(GL_OES_standard_derivatives)
    dx = dFdx(depth);
    dy = dFdy(depth);
  #endif

  float moment2 = depth * depth + 0.25 * (dx * dx + dy * dy);
  FRAG_COLOR = vec4(1.0 - depth, 1.0 - moment2, 0.0, 0.0);
}`};class kn{constructor(){this._maxInstances=20,this._modelMatrix=[new p.Buffer,new p.Buffer,new p.Buffer,new p.Buffer],this.expandBuffers(this._maxInstances)}expandBuffers(e){for(;e>this._maxInstances;)this._maxInstances+=Math.floor(this._maxInstances*.5);for(let t=0;t<4;t++)this._modelMatrix[t].update(new Float32Array(4*this._maxInstances))}updateBuffers(e){e.length>this._maxInstances&&this.expandBuffers(e.length);for(let t=0;t<e.length;t++){const n=e[t].worldTransform.array;for(let i=0;i<4;i++)this._modelMatrix[i].data.set(n.slice(i*4,i*4+4),t*4)}for(let t=0;t<4;t++)this._modelMatrix[t].update()}addGeometryAttributes(e){for(let t=0;t<4;t++)e.addAttribute(`a_ModelMatrix${t}`,this._modelMatrix[t],4,!1,void 0,0,void 0,!0)}}var ut;(r=>{function e(t,n=[]){return t.context.webGLVersion===1&&n.push("WEBGL1 1"),t.context.webGLVersion===2&&n.push("WEBGL2 1"),n}r.build=e})(ut||(ut={}));class He extends Ae{constructor(e,t=[]){t=ut.build(e,t),super(p.Program.from(de.build(zn.source,t,e),de.build(jn.source,t,e))),this._instancing=new kn}get maxSupportedJoints(){return 0}createShaderGeometry(e,t){let n=new p.Geometry;return e.indices&&(e.indices.buffer.BYTES_PER_ELEMENT===1?n.addIndex(new p.Buffer(new Uint16Array(e.indices.buffer))):n.addIndex(new p.Buffer(e.indices.buffer))),e.positions&&n.addAttribute("a_Position",new p.Buffer(e.positions.buffer),3,!1,e.positions.componentType,e.positions.stride),t&&this._instancing.addGeometryAttributes(n),n}get name(){return"shadow-shader"}render(e,t,n){if(e.instances.length>0){const i=e.instances.filter(a=>a.worldVisible&&a.renderable);if(i.length===0)return;this._instancing.updateBuffers(i)}super.render(e,t,n)}updateUniforms(e,t){this.uniforms.u_ModelMatrix=e.worldTransform.array,this.uniforms.u_ViewProjectionMatrix=t.lightViewProjection}}class ct extends He{constructor(e){const t=ct.getMaxJointCount(e)-1;super(e,["USE_SKINNING 1","MAX_JOINT_COUNT "+t]),this._maxSupportedJoints=t}get maxSupportedJoints(){return this._maxSupportedJoints}static getMaxJointCount(e){let t=8,n=ee.getMaxVertexUniformVectors(e)-t;return Math.floor(n/4)}createShaderGeometry(e,t){let n=super.createShaderGeometry(e,t);return e.joints&&n.addAttribute("a_Joint1",new p.Buffer(e.joints.buffer),4,!1,e.joints.componentType,e.joints.stride),e.weights&&n.addAttribute("a_Weight1",new p.Buffer(e.weights.buffer),4,!1,e.weights.componentType,e.weights.stride),n}get name(){return"skinned-shadow-shader"}updateUniforms(e,t){super.updateUniforms(e,t),e.skin&&(this.uniforms.u_jointMatrix=e.skin.jointMatrices)}}const dt=256;class Yt extends He{constructor(e){super(e,["USE_SKINNING 1","USE_SKINNING_TEXTURE 1","MAX_JOINT_COUNT "+dt]),this._jointMatrixTexture=new we(dt)}static isSupported(e){return we.isSupported(e)}get maxSupportedJoints(){return dt}createShaderGeometry(e,t){let n=super.createShaderGeometry(e,t);return e.joints&&n.addAttribute("a_Joint1",new p.Buffer(e.joints.buffer),4,!1,e.joints.componentType,e.joints.stride),e.weights&&n.addAttribute("a_Weight1",new p.Buffer(e.weights.buffer),4,!1,e.weights.componentType,e.weights.stride),n}get name(){return"skinned-shadow-shader"}updateUniforms(e,t){super.updateUniforms(e,t),e.skin&&(this._jointMatrixTexture.updateBuffer(e.skin.jointMatrices),this.uniforms.u_jointMatrixSampler=this._jointMatrixTexture)}}class Qn{constructor(e){this.renderer=e,this._state=Object.assign(new p.State,{depthTest:!0,clockwiseFrontFace:!1,culling:!0,blendMode:C.BLEND_MODES.NONE}),this._shadowShader=new He(this.renderer),this._instancedShadowShader=new He(this.renderer,["USE_INSTANCING 1"])}getSkinningShader(){return this._textureShader||this._skinningShader?this._textureShader||this._skinningShader:(Yt.isSupported(this.renderer)?this._textureShader=new Yt(this.renderer):(v.Debug.warn(ve.meshVertexSkinningFloatingPointTexturesNotSupported),this._skinningShader=new ct(this.renderer)),this._textureShader||this._skinningShader)}render(e,t){let n=e.instances.length>0?this._instancedShadowShader:this._shadowShader;if(e.skin){let i=this.getSkinningShader();i&&e.skin.joints.length>i.maxSupportedJoints?v.Debug.error(ve.meshVertexSkinningNumberOfJointsNotSupported,{joints:e.skin.joints.length,maxJoints:i.maxSupportedJoints}):n=i}n&&(n.updateUniforms(e,t),n.render(e,this.renderer,this._state))}}class Zt{constructor(e,t="shadow"){this.renderer=e,this.name=t,this._lights=[],this._filter=new Hn(e),this._shadow=new Qn(e)}addShadowCastingLight(e){this._lights.indexOf(e)<0&&this._lights.push(e)}removeShadowCastingLight(e){const t=this._lights.indexOf(e);t>=0&&this._lights.splice(t,1)}clear(){for(let e of this._lights)e.clear()}render(e){if(e.length===0||this._lights.length===0)return;const t=this.renderer.renderTexture.current;for(let n of this._lights){this.renderer.renderTexture.bind(n.shadowTexture),n.updateLightViewProjection();for(let i of e)this._shadow.render(i,n);n.softness>0&&this._filter.applyGaussianBlur(n)}this.renderer.renderTexture.bind(t||void 0)}}class Wn extends p.BatchGeometry{constructor(){super(),this.addAttribute("aMatrix0",this._buffer,4,!1,C.TYPES.FLOAT),this.addAttribute("aMatrix1",this._buffer,4,!1,C.TYPES.FLOAT),this.addAttribute("aMatrix2",this._buffer,4,!1,C.TYPES.FLOAT),this.addAttribute("aMatrix3",this._buffer,4,!1,C.TYPES.FLOAT)}}var Xn={source:`precision highp float;

attribute vec2 aVertexPosition;

attribute vec4 aMatrix0;
attribute vec4 aMatrix1;
attribute vec4 aMatrix2;
attribute vec4 aMatrix3;

attribute vec2 aTextureCoord;
attribute vec4 aColor;
attribute float aTextureId;

uniform vec4 tint;

varying vec2 vTextureCoord;
varying vec4 vColor;
varying float vTextureId;

void main(void) {
  mat4 modelMatrix = mat4(aMatrix0, aMatrix1, aMatrix2, aMatrix3);

  gl_Position = modelMatrix * vec4(aVertexPosition.xy, 0.0, 1.0);

  vTextureCoord = vec2(aTextureCoord.x, aTextureCoord.y);
  vTextureId = aTextureId;
  vColor = aColor * tint;
}`},Jn={source:`varying vec2 vTextureCoord;
varying vec4 vColor;
varying float vTextureId;

uniform sampler2D uSamplers[%count%];

void main(void){
    vec4 color;
    %forloop%
    gl_FragColor = vColor * vec4(color.rgb, color.a);
}`};const Kn=O.get(P,"BatchRenderer")||O.get(P,"AbstractBatchRenderer");class ft extends Kn{constructor(e){super(e),this.shaderGenerator=new p.BatchShaderGenerator(Xn.source,Jn.source),this.geometryClass=Wn,this.vertexSize=22,Object.assign(this.state,{culling:!1,clockwiseFrontFace:!1,depthTest:!0})}packInterleavedGeometry(e,t,n,i,a){const{uint32View:s,float32View:o}=t,h=i/this.vertexSize,l=e.uvs,u=e.indices,d=e.vertexData,c=e._texture.baseTexture._batchLocation,f=Math.min(e.worldAlpha,1),_=f<1&&e._texture.baseTexture.alphaMode?Xe.premultiplyTint(e._tintRGB,f):e._tintRGB+(f*255<<24);for(let m=0;m<d.length;m+=2){o[i++]=d[m],o[i++]=d[m+1],o[i++]=l[m],o[i++]=l[m+1],s[i++]=_,o[i++]=c;let g=e.modelViewProjection.array;for(let A=0;A<16;A++)o[i++]=g[A]}for(let m=0;m<u.length;m++)n[a++]=h+u[m]}}N.installRendererPlugin("sprite3d",ft);class $t extends p.ObjectRenderer{constructor(e){super(e),this.renderer=e,this._meshes=[],this._sprites=[],this.materialPass=new qt(this.renderer,"material"),this.shadowPass=new Zt(this.renderer,"shadow"),this.renderPasses=[this.shadowPass,this.materialPass],e.on("prerender",()=>{for(let t of this.renderPasses)t.clear&&t.clear()}),this._spriteRenderer=new ft(e)}render(e){e.isSprite?this._sprites.push(e):this._meshes.push(e)}flush(){this.sort();for(let e of this.renderPasses)e.render(this._meshes.filter(t=>t.isRenderPassEnabled(e.name)));if(this._meshes=[],this._sprites.length>0){this._spriteRenderer.start();for(let e of this._sprites)this._spriteRenderer.render(e);this._spriteRenderer.stop(),this._sprites=[]}}sort(){this._meshes.sort((e,t)=>!e.material||!t.material?0:e.material.renderSortType!==t.material.renderSortType?e.material.renderSortType===ye.transparent?1:-1:e.renderSortOrder===t.renderSortOrder?0:e.renderSortOrder<t.renderSortOrder?-1:1),this._sprites.sort((e,t)=>e.zIndex!==t.zIndex?e.zIndex-t.zIndex:t.distanceFromCamera-e.distanceFromCamera)}enableShadows(e,t){let n=e instanceof Ve?e.meshes:[e];for(let i of n)t&&i.material instanceof ie&&(i.material.shadowCastingLight=t),i.enableRenderPass(this.shadowPass.name);t&&this.shadowPass.addShadowCastingLight(t)}disableShadows(e){let t=e instanceof Ve?e.meshes:[e];for(let n of t)n.material instanceof ie&&(n.material.shadowCastingLight=void 0),n.disableRenderPass(this.shadowPass.name)}}N.installRendererPlugin("pipeline",$t);const qn=O.get(P,"ArrayResource")||O.get(P,"resources").ArrayResource,Yn=O.get(P,"BaseImageResource")||O.get(P,"resources").BaseImageResource;class er extends qn{constructor(e,t){super(e),this.target=t}upload(e,t){e.gl.pixelStorei(e.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,t.alphaMode===C.ALPHA_MODES.UNPACK);for(let n=0;n<this.items.length;n++){const i=this.items[n].resource;i instanceof rt&&e.gl.texImage2D(this.target,n,t.format,i.width,i.height,0,t.format,t.type,i.data),i instanceof Yn&&e.gl.texImage2D(this.target,n,t.format,t.format,t.type,i.source)}return!0}}const Zn=O.get(P,"CubeResource")||O.get(P,"resources").CubeResource;class mt extends Zn{constructor(e,t=1){super(e),this.levels=t}style(e){let t=e.gl;return t.texParameteri(t.TEXTURE_CUBE_MAP,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_CUBE_MAP,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),this.levels>1?t.texParameteri(t.TEXTURE_CUBE_MAP,t.TEXTURE_MIN_FILTER,t.LINEAR_MIPMAP_LINEAR):t.texParameteri(t.TEXTURE_CUBE_MAP,t.TEXTURE_MIN_FILTER,t.LINEAR),!0}}class ae extends p.BaseTexture{constructor(){super(...arguments),this.cubemapFormat=Se.ldr}static get faces(){return["posx","negx","posy","negy","posz","negz"]}get levels(){return this.resource.levels}static fromFaces(e){const t=Array.isArray(e)?e:[e],n=ae.faces.map((i,a)=>new er(t.map(s=>s[i]),C.TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X+a));return new ae(new mt(n,t.length))}static fromColors(e,t=e,n=e,i=e,a=e,s=e){const o=[],h=[e,t,n,i,a,s];for(let l=0;l<h.length;l++){let u=new rt(new Uint8Array(h[l].rgba.map(c=>c*255)),{width:1,height:1}),d=new p.Texture(new p.BaseTexture(u,{type:C.TYPES.UNSIGNED_BYTE,format:C.FORMATS.RGB,alphaMode:C.ALPHA_MODES.NO_PREMULTIPLIED_ALPHA}));o.push(new er([d],C.TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X+l))}return new ae(new mt(o,1))}}class $n{constructor(e){this.json=e}get format(){return Se.ldr}get mipmaps(){return this.json}}class ei{constructor(e){this.json=e}get format(){return this.json.format}get mipmaps(){return this.json.mipmaps}}var ze;(r=>{function e(t){return t.version===2?new ei(t):new $n(t)}r.getFileVersion=e})(ze||(ze={}));const tr={use:function(r,e){if(r.extension!=="cubemap")return e();const t=this,n=ze.getFileVersion(r.data),i=n.mipmaps.map(h=>ae.faces.map(l=>r.url.substring(0,r.url.lastIndexOf("/")+1)+h.replace("{{face}}",l)));let a=i.reduce((h,l)=>h.concat(l),[]);t.add(a.filter(h=>!t.resources[h]).map(h=>({parentResource:r,url:h})));let s=0,o=t.onLoad.add((h,l)=>{if(a.includes(l.url)&&++s===a.length){const u=i.map(c=>({posx:p.Texture.from(c[0]),negx:p.Texture.from(c[1]),posy:p.Texture.from(c[2]),negy:p.Texture.from(c[3]),posz:p.Texture.from(c[4]),negz:p.Texture.from(c[5])}));let d=ae.fromFaces(u);d.cubemapFormat=n.format,r.cubemap=d,o.detach(),e()}})},add:function(){N.setLoaderResourceExtensionType("cubemap",ue.json)},test(r){return r.includes(".cubemap")},async load(r){if(!N.assets)throw new Error("PIXI3D: This feature is only available when using PixiJS v7+");const e=await(await Te.settings.ADAPTER.fetch(r)).json(),t=ze.getFileVersion(e),n=t.mipmaps.map(s=>ae.faces.map(o=>r.substring(0,r.lastIndexOf("/")+1)+s.replace("{{face}}",o))),i=[];for(let s of n){let o={posx:await N.assets.load(s[0]),negx:await N.assets.load(s[1]),posy:await N.assets.load(s[2]),negy:await N.assets.load(s[3]),posz:await N.assets.load(s[4]),negz:await N.assets.load(s[5])};i.push(o)}let a=ae.fromFaces(i);return a.cubemapFormat=t.format,a}};N.installLoaderPlugin("cubemap",tr);const ti=["glsl","vert","frag"],rr={use:(r,e)=>{e()},add:function(){for(let r of ti)N.setLoaderResourceExtensionType(r,ue.text)},test(r){return r.includes(".glsl")||r.includes(".vert")||r.includes(".frag")},async load(r){return await(await Te.settings.ADAPTER.fetch(r)).text()}};N.installLoaderPlugin("shader",rr);var ri={source:`attribute vec3 a_Position;

varying vec3 v_Position;

uniform mat4 u_ModelMatrix;
uniform mat4 u_View;
uniform mat4 u_Projection;

void main() {
  v_Position = a_Position.xyz;

  // Converting the view to 3x3 matrix and then back to 4x4 matrix 
  // removes the translation. We do this because we want the skybox to 
  // be centered around the camera.
  gl_Position = u_Projection * mat4(mat3(u_View)) * u_ModelMatrix * vec4(a_Position, 1.0);
}`},ni={source:`varying vec3 v_Position;

uniform samplerCube u_EnvironmentSampler;
uniform bool u_RGBE;
uniform float u_Exposure;

const float GAMMA = 2.2;
const float INV_GAMMA = 1.0 / GAMMA;

// linear to sRGB approximation
// see http://chilliant.blogspot.com/2012/08/srgb-approximations-for-hlsl.html
vec3 linearToSRGB(vec3 color)
{
    return pow(color, vec3(INV_GAMMA));
}

vec3 decodeRGBE(vec4 rgbe) {
  vec3 vDecoded;
  float fExp = rgbe.a * 255.0 - 128.0;
  vDecoded = rgbe.rgb * exp2(fExp);
  return vDecoded;
}

void main() {
  vec4 color = textureCube(u_EnvironmentSampler, v_Position);
  gl_FragColor = vec4(color.rgb * u_Exposure, 1.0);
  if (u_RGBE) {
    color = vec4(decodeRGBE(color), 1.0);
    gl_FragColor = vec4(linearToSRGB(color.rgb * u_Exposure), 1.0);
  }
}`};class ii extends Ce{constructor(e){super(),this.exposure=1,this._cubemap=e,this.state=Object.assign(new p.State,{culling:!0,clockwiseFrontFace:!0,depthTest:!0,depthMask:!1})}get cubemap(){return this._cubemap}set cubemap(e){e!==this._cubemap&&(this._cubemap.valid||(this._shader=void 0),this._cubemap=e)}updateUniforms(e,t){let n=this.camera||k.main;t.uniforms.u_ModelMatrix=e.worldTransform.array,t.uniforms.u_View=n.view.array,t.uniforms.u_Projection=n.projection.array,t.uniforms.u_EnvironmentSampler=this.cubemap,t.uniforms.u_RGBE=this.cubemap.cubemapFormat===Se.rgbe8,t.uniforms.u_Exposure=this.exposure}render(e,t){t.gl.depthMask(!1),super.render(e,t),t.gl.depthMask(!0)}createShader(){if(this.cubemap.valid)return new Ae(p.Program.from(ri.source,ni.source))}}class _t extends J{constructor(e){super(),this._mesh=this.addChild(q.createCube(new ii(e))),this._mesh.renderSortOrder=-1}get camera(){return this._mesh.material.camera}set camera(e){this._mesh.material.camera=e}get exposure(){return this._mesh.material.exposure}set exposure(e){this._mesh.material.exposure=e}get cubemap(){return this._mesh.material.cubemap}set cubemap(e){this._mesh.material.cubemap=e}static from(e){return new _t(ae.fromFaces(e))}}var ai={source:`#version 100

attribute vec3 a_Position;

uniform mat4 u_ModelViewProjection;

void main() {
  gl_Position = u_ModelViewProjection * vec4(a_Position, 1.0);
}`},si={source:`#version 100

#ifdef GL_FRAGMENT_PRECISION_HIGH
  precision highp float;
#else
  precision mediump float;
#endif

uniform vec3 u_Id;

void main() {
  gl_FragColor = vec4(u_Id / 255.0, 1.0);
}`};class oi{constructor(e,t){this._renderer=e,this._update=0,this._matrix=new Float32Array(16),this._pixels=new Uint8Array(t*t*4),this._output=p.RenderTexture.create({width:t,height:t,resolution:1}),this._shader=new Ae(p.Program.from(ai.source,si.source)),this._output.framebuffer.addDepthTexture()}destroy(){this._output.destroy(!0),this._shader.destroy()}resizeToAspect(){const e=this._renderer.width/this._renderer.height,t=Math.floor(this._output.height*e);this._output.width!==t&&(this._pixels=new Uint8Array(t*this._output.height*4),this._output.resize(t,this._output.height))}containsId(e,t,n){const{width:i,height:a}=this._renderer.screen;e=Math.floor(e/i*this._output.width),t=Math.floor((a-t)/a*this._output.height);for(let s=0;s<3;s++)if(n[s]!==this._pixels[(t*this._output.width+e)*4+s])return!1;return!0}update(e){if(this._renderer.renderTexture.bind(this._output),this._update++%2===0){this._renderer.renderTexture.clear();for(let t of e)this.renderHitArea(t)}else{const t=this._renderer.gl;t.readPixels(0,0,this._output.width,this._output.height,t.RGBA,t.UNSIGNED_BYTE,this._pixels)}this._renderer.renderTexture.bind(void 0)}renderHitArea(e){const t=this._shader.uniforms,n=e.object instanceof q?[e.object]:e.object.meshes,i=e.camera||k.main;for(let a of n)t.u_Id=e.id,t.u_ModelViewProjection=T.multiply(i.viewProjection.array,a.transform.worldTransform.array,this._matrix),this._shader.render(a,this._renderer)}}class _e{constructor(e){this.renderer=e,this._hitAreas=[],this._map=new oi(this.renderer,128),ge.Ticker.shared.add(this._update,this,ge.UPDATE_PRIORITY.LOW),_e.main||(_e.main=this)}_update(){if(!this.renderer.plugins)return;let e=N.getInteractionPlugin(this.renderer);e&&e.hitTest(new H.Point(0,0)),this._hitAreas.length>0&&(this._map.resizeToAspect(),this._map.update(this._hitAreas),this._hitAreas=[])}destroy(){this===_e.main&&(_e.main=void 0),ge.Ticker.shared.remove(this._update,this)}containsHitArea(e,t,n){return this._hitAreas.indexOf(n)<0&&this._hitAreas.push(n),this._map.containsId(e,t,n.id)}}N.installRendererPlugin("picking",_e);var gt;(r=>{let e=0;function t(){return e++,new Uint8Array([e>>16&255,e>>8&255,e&255])}r.next=t})(gt||(gt={}));class li{constructor(e,t){this.object=e,this.camera=t,this.id=gt.next()}contains(e,t){return _e.main.containsHitArea(e,t,this)}}var Ne=(r=>(r.low="low",r.medium="medium",r.high="high",r))(Ne||{}),je;(r=>{function e(i,a,s){let o=n(i,s);return p.RenderTexture.create({width:a,height:a,type:o,scaleMode:t(i)})}r.create=e;function t(i){return ee.supportsFloatLinear(i)?C.SCALE_MODES.LINEAR:C.SCALE_MODES.NEAREST}function n(i,a){if(a===Ne.high){if(ee.isFloatFramebufferSupported(i))return C.TYPES.FLOAT;if(ee.isHalfFloatFramebufferSupported(i))return C.TYPES.HALF_FLOAT}return a===Ne.medium&&ee.isHalfFloatFramebufferSupported(i)?C.TYPES.HALF_FLOAT:C.TYPES.UNSIGNED_BYTE}})(je||(je={}));var ke;(r=>{const e=new Float32Array(16),t=new Float32Array(16),n=new Float32Array(4),i=new Float32Array(3),a=new Float32Array(3),s=new Float32Array(3),o=new Float32Array(3);function h(u){if(u.light.type!==re.directional)return;let d=u.shadowArea/2,c=d*2/u.shadowArea,f=T.ortho(-d,d,-d,d,-d,d,e),_=u.light,m=u.camera||k.main;m&&u.followCamera?(x.scale(m.worldTransform.forward.array,d,o),x.add(m.worldTransform.position.array,o,s),x.transformQuat(s,D.conjugate(u.light.worldTransform.rotation.array,n),i),i[0]=c*Math.floor(i[0]/c),i[1]=c*Math.floor(i[1]/c),x.transformQuat(i,_.worldTransform.rotation.array,i),x.add(i,_.worldTransform.forward.array,a),T.lookAt(i,a,_.worldTransform.up.array,t),T.multiply(f,t,u.lightViewProjection)):(x.add(_.worldTransform.position.array,u.light.worldTransform.forward.array,s),T.lookAt(_.worldTransform.position.array,s,_.worldTransform.up.array,t),T.multiply(f,t,u.lightViewProjection))}r.calculateDirectionalLightViewProjection=h;function l(u){if(u.light.type!==re.spot)return;let d=u.light;T.perspective(d.outerConeAngle*H.DEG_TO_RAD*2,1,2,d.range,e),x.add(d.worldTransform.position.array,d.worldTransform.forward.array,s),T.lookAt(d.worldTransform.position.array,s,d.worldTransform.up.array,t),T.multiply(e,t,u.lightViewProjection)}r.calculateSpotLightViewProjection=l})(ke||(ke={}));class hi{constructor(e,t,n){if(this.renderer=e,this.light=t,this._lightViewProjection=new Float32Array(16),this.softness=0,this.shadowArea=50,this.followCamera=!0,t.type===re.point)throw new Error("PIXI3D: Only directional and spot lights are supported as shadow casters.");const{shadowTextureSize:i=1024,quality:a=Ne.medium}=n||{};this._shadowTexture=je.create(e,i,a),this._shadowTexture.baseTexture.framebuffer.addDepthTexture(),this._filterTexture=je.create(e,i,a)}get lightViewProjection(){return this._lightViewProjection}get shadowTexture(){return this._shadowTexture}get filterTexture(){return this._filterTexture}destroy(){this._shadowTexture.destroy(!0),this._filterTexture.destroy(!0)}clear(){this.renderer.renderTexture.bind(this._shadowTexture),this.renderer.renderTexture.clear([0,0,0,0],this.renderer.gl.COLOR_BUFFER_BIT|this.renderer.gl.DEPTH_BUFFER_BIT),this.renderer.renderTexture.bind(void 0)}updateLightViewProjection(){this.light.type===re.directional?ke.calculateDirectionalLightViewProjection(this):this.light.type===re.spot&&ke.calculateSpotLightViewProjection(this)}static isMediumQualitySupported(e){return ee.isHalfFloatFramebufferSupported(e)}static isHighQualitySupported(e){return ee.isFloatFramebufferSupported(e)}}class ui extends St.Sprite{constructor(e,t){super(),this.renderer=e,this._tickerRender=()=>{};let{width:n=512,height:i=512,objectToRender:a,resolution:s=1}=t||{};this._renderTexture=p.RenderTexture.create({width:n,height:i,resolution:s}),this._renderTexture.rotate=8,this._renderTexture.baseTexture.framebuffer.depth=!0,this._texture=this._renderTexture,(!t||!t.width||!t.height)&&e.on("prerender",()=>{this._renderTexture.resize(e.screen.width,e.screen.height)}),a&&(this._tickerRender=()=>{if(N.isRendererDestroyed(e)){ge.Ticker.shared.remove(this._tickerRender);return}this.worldVisible&&this.worldAlpha>0&&this.renderable&&a&&this.renderObject(a)},ge.Ticker.shared.add(this._tickerRender))}get renderTexture(){return this._renderTexture}setResolution(e){this._renderTexture.setResolution(e),this._renderTexture.resize(this._renderTexture.width,this._renderTexture.height,!0)}destroy(e){ge.Ticker.shared.remove(this._tickerRender),super.destroy(e)}renderObject(e){N.render(this.renderer,e,this.renderTexture)}}function ci(r,e){return Math.abs(r-e)<=di*Math.max(1,Math.abs(r),Math.abs(e))}const di=1e-6;class pt{constructor(e,t){this.distance=t,this._normal=new b,this._normal=e.normalize(this._normal)}static from(e,t){return new pt(t,b.dot(e,t))}get normal(){return this._normal}rayCast(e){const t=b.dot(e.direction,this.normal);return ci(t,0)?0:(-b.dot(e.origin,this.normal)-this.distance)/t}}var Qe=(r=>(r.spherical="spherical",r.cylindrical="cylindrical",r))(Qe||{});class fi extends St.Sprite{constructor(e){super(e),this._pixelsPerUnit=100,this.distanceFromCamera=0,this.modelViewProjection=new I,this.pluginName="pipeline"}get pixelsPerUnit(){return this._pixelsPerUnit}set pixelsPerUnit(e){e!==this._pixelsPerUnit&&(this._transformID=-1,this._pixelsPerUnit=e)}calculateVertices(){const e=this._texture;if(this._transformID===this.transform._worldID&&this._textureID===e._updateID)return;this._textureID!==e._updateID&&(this.uvs=this._texture._uvs.uvsFloat32),this._transformID=this.transform._worldID,this._textureID=e._updateID;const t=this.transform.worldTransform,n=e.orig,i=this._anchor,a=e.trim?e.trim.x-i._x*n.width:-i._x*n.width,s=e.trim?a+e.trim.width:a+n.width,o=e.trim?e.trim.y-i._y*n.height:-i._y*n.height,h=e.trim?o+e.trim.height:o+n.height;if(this.vertexData[0]=(t.a*a+t.c*-o)/this._pixelsPerUnit,this.vertexData[1]=(t.d*-o+t.b*a)/this._pixelsPerUnit,this.vertexData[2]=(t.a*s+t.c*-o)/this._pixelsPerUnit,this.vertexData[3]=(t.d*-o+t.b*s)/this._pixelsPerUnit,this.vertexData[4]=(t.a*s+t.c*-h)/this._pixelsPerUnit,this.vertexData[5]=(t.d*-h+t.b*s)/this._pixelsPerUnit,this.vertexData[6]=(t.a*a+t.c*-h)/this._pixelsPerUnit,this.vertexData[7]=(t.d*-h+t.b*a)/this._pixelsPerUnit,this.roundPixels){const u=Te.settings.RESOLUTION;for(var l=0;l<this.vertexData.length;++l)this.vertexData[l]=Math.round((this.vertexData[l]*u|0)/u)}}}const nr=new Float32Array(3);class mi extends J{constructor(e){super(),this._modelView=new Float32Array(16),this._sprite=new fi(e),this._sprite.anchor.set(.5)}get billboardType(){return this._billboardType}set billboardType(e){e!==this._billboardType&&(this._billboardType=e,this._cameraTransformId=void 0)}get pixelsPerUnit(){return this._sprite.pixelsPerUnit}set pixelsPerUnit(e){this._sprite.pixelsPerUnit=e}get renderSortOrder(){return this._sprite.zIndex}set renderSortOrder(e){this._sprite.zIndex=e}get tint(){return this._sprite.tint}set tint(e){this._sprite.tint=e}destroy(e){super.destroy(e),this._sprite.destroy(e)}_render(e){const t=this.camera||k.main;if(t.transformId!==this._cameraTransformId||this._parentID!==this.transform._worldID){const n=this.worldTransform.scaling;switch(T.multiply(t.view.array,this.worldTransform.array,this._modelView),this._billboardType){case Qe.spherical:{this._modelView[0]=n.x,this._modelView[1]=0,this._modelView[2]=0,this._modelView[3]=0,this._modelView[4]=0,this._modelView[5]=n.y,this._modelView[6]=0,this._modelView[7]=0;break}case Qe.cylindrical:{this._modelView[0]=n.x,this._modelView[1]=0,this._modelView[2]=0,this._modelView[3]=0,this._modelView[8]=0,this._modelView[9]=0,this._modelView[10]=1,this._modelView[11]=0;break}}T.multiply(t.projection.array,this._modelView,this._sprite.modelViewProjection.array),this._parentID=this.transform._worldID,this._cameraTransformId=t.transformId;const i=x.subtract(t.worldTransform.position.array,this.worldTransform.position.array,nr),a=x.scale(t.worldTransform.forward.array,x.dot(i,t.worldTransform.forward.array),nr);this._sprite.distanceFromCamera=x.squaredMagnitude(a)}this._sprite.worldAlpha=this.worldAlpha,this._sprite.render(e)}get anchor(){return this._sprite.anchor}set anchor(e){this._sprite.anchor=e}get texture(){return this._sprite.texture}set texture(e){this._sprite.texture=e}get blendMode(){return this._sprite.blendMode}set blendMode(e){this._sprite.blendMode=e}}return v.AABB=Ie,v.Animation=kt,v.Camera=k,v.CameraOrbitControl=An,v.Color=K,v.CompositeSprite=ui,v.Container3D=J,v.Cubemap=ae,v.CubemapFormat=Se,v.CubemapLoader=tr,v.CubemapResource=mt,v.Fog=Bn,v.ImageBasedLighting=it,v.InstancedModel=Kt,v.InstancedStandardMaterial=Dt,v.Joint=Wt,v.Light=Dn,v.LightType=re,v.LightingEnvironment=fe,v.Mat4=T,v.Material=Ce,v.MaterialRenderPass=qt,v.MaterialRenderSortType=ye,v.Matrix4x4=I,v.Mesh3D=q,v.MeshGeometry3D=ce,v.MeshShader=Ae,v.Model=Ve,v.PickingHitArea=li,v.PickingInteraction=_e,v.Plane=pt,v.Point3D=b,v.Quat=D,v.Quaternion=X,v.Ray=Ze,v.ShaderSourceLoader=rr,v.ShadowCastingLight=hi,v.ShadowQuality=Ne,v.ShadowRenderPass=Zt,v.Skin=Qt,v.Skybox=_t,v.Sprite3D=mi,v.SpriteBatchRenderer=ft,v.SpriteBillboardType=Qe,v.StandardMaterial=ie,v.StandardMaterialAlphaMode=oe,v.StandardMaterialDebugMode=le,v.StandardMaterialNormalTexture=Vt,v.StandardMaterialOcclusionTexture=Ht,v.StandardMaterialTexture=Ee,v.StandardPipeline=$t,v.TextureTransform=he,v.Transform3D=Oe,v.Vec3=x,v.glTFAsset=j,v.glTFBinaryLoader=Ct,v.glTFLoader=Rt,Object.defineProperty(v,"__esModule",{value:!0}),v}({},PIXI,PIXI,PIXI,PIXI,PIXI,PIXI,PIXI,PIXI.utils,PIXI,PIXI);
//# sourceMappingURL=pixi3d.min.js.map
